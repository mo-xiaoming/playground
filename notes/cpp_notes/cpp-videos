-- [T] threading/vectorization
-- [A] allocator
-- [D] delete
-- [E] exceptional
-- [K] keep
[D] 'Keep It C-mple' Alexander Radchenko Sydney C++ Meetup-lTXHOOwfTAo.mp4
  - use c stype functions more, instead of nested namespaces. Easy to search in code base
[K] 'New' Features in C - Dan Saks-ieERUEhs910.mp4
  - goodies in modern C, useful if I want to write C someday
[D] 2013 Keynote - Chandler Carruth - Optimizing the Emergent Structures of C++-eR34r7HOU14.mp4
  - IR / compiler stuff, pass by value is good
[E] 50 shades of C++  - Nicolai Josuttis - Meeting C++ 2018 Closing Keynote-9-_TLTdLGtc.mp4
  - Initialization
  - setter/getter and move and hidden friend for a simple Customer class
  - value categories, universal reference
  - style guides
[E] A Low-Latency Library in FPGA Hardware for High-Frequency Trading [nXFcM1pGOIE].mp4
[T] A Multi-threaded, Transaction-Based Locking Strategy for Containers - Bob Steagall - CppCon 2020-Pi243hGxDyA.mp4
[E] A Possible Future of Software Development-4moyKUHApq4.mp4
  - Binary search problem for interviews and more
  - We don't solve problems, we approximate solutions
  - Math <-> Programming
  - DAG
[M] A Relaxed Guide to memory_order_relaxed - Paul E. McKenney & Hans Boehm - CppCon 2020-cWkUqK71DZ0.mp4
[T] A lock-free std - -atomic std - -shared_ptr - Timur Doumler - ACCU 2022 [a10JpqI-CvU].mp4
  - atomic<shared_ptr> is not lock free, correct his mistake on _CppCon 2015: Timur Doumler "C++ in the Audio Industry"_
  - correct his another mistake on _Lock-free programming wiht modern C++ - Timur Doumler [ACCU 2017]_
[D] A refresher on the floating-point computations and the standard library. - Boguslaw Cyganek-7aZbYJ5UTC8.mp4
[A] Advanced Dependencies Model in Conan 2.0 C, C++ Package Manager - Diego Rodriguez-Losada - ACCU 2022 [kKGglzm5ous].mp4
[T] Adventures in SIMD-Thinking (part 1 of 2) - Bob Steagall - CppCon 2020-qejTqnxQRcw.mp4
[T] Adventures in SIMD-Thinking (part 2 of 2) - Bob Steagall - CppCon 2020-qXleSwCCEvY.mp4
[K] Algorithmic and microarchitecture optimizations of C++ applications - Alexander Maslennikov C++onSea-QLHQhzy1W4Y.mp4
  - -O2/-O3
  - -march -mtune -mcpu
  - analyse tools and vectorization, and threading
  - front-end bound, back-end bound, bad speculation
[D] Algorithms from a Compiler Developer's Toolbox - Gábor Horváth - [CppNow 2021]-eeS1WP7FK-A.mp4
  - how to transform loop to x(x+1)/2, by algebra
  - value numbering
[D] Alices adventures in Template Land - Jonathan O'Connor - Meeting C++ 2018-LSVdQJzblBQ.mp4
[E] An Adventure in Race Conditions - Felix Petriconi [ACCU 2019]-asgO4P2fhTw.mp4
  - easy to get wrong with primitive mutex etc.
  - hight-level abstraction with boost and stlib
[D] Andreas Buhr - C++ Coroutines-vzC2iRfO_H8.mp4
[D] Arno Lepisk - Testing non-compiling code-02Hu0amx-5Y.mp4
  - script to test exit status, too slow in CI and unreliable
  - static_assert on traits
[K] Back to Basics - Algebraic Data Types - Arthur O'Dwyer - CppCon 2020-OJzmWqCCZaM.mp4
  - optional variant pair tuple, usages
[D] Back to Basics - Casting - Brian Ruth - CppCon 2021-2h2hdRqRIRk.mp4
[E] Back to Basics - Class Layout - Stephen Dewhurst - CppCon 2020-SShSV_iV1Ko.mp4
  - EBO
  - standard_layout, scary
  - force alignment
  - Good idea to check
  - has_unique_object_representations_v for == optimization, more like this in c++ concepts
  - vptr
  - void* is dangerous for comparason
[T] Back to Basics - Concurrency - Arthur O'Dwyer - CppCon 2020-F6Ipn7gCOsY.mp4
[K] Back to Basics - The Abstract Machine - Bob Steagall - CppCon 2020-ZAji7PkXaKY.mp4
[E] Benchmarking C++, From video games to algorithmic trading - Alexander Radchenko - Meeting C++ 2018-7YVMC5v4qCA.mp4
  - games in microseconds, trading in nanoseconds
  - Cache!!
  - L3 is shared by all cores, choose neighbours wisely
  - L1 is shared by HT, so disable them
  - All data in cache
  - Cache warming: keep running and touching memory, loop { generating order and drop it}
  - chrono for profiling
  - Jupiter to analysis the data
  - and other tools
  - optimize FizzBuzz
[E] Better Code - Concurrency - Sean Parent-zULU6Hhp42w.mp4
  - No raw synchronization primitives
  - Compute power: GPU >> Vectorization >> Multithreading >> Straight C++(0.125%)
  - Amdahl's law, minimize locks
  - Sequential consistency
  - Tasks are scheduled on a thread pool to optimze machine utilization
  - Building a task system
  - Future for continuations
  - stlab for channels and everything
[E] Better Code - Relationships - Sean Parent  [ ACCU 2021 ]-f5UsHQW7-9w.mp4
[E] Better Code - Runtime Polymorphism - Sean Parent-QGcVXgEVMJg.mp4
[K] Beware of C++ - Nicolai Josuttis-tCM4wP-dWic.mp4
  - the mess of
  - noexcept
  - initializer list and explicit
  - constexpr
  - make_pair and template parameters
[D] Bjarne Stroustrup - C++20 Generic Programming-03BtQljH2oA.mp4
[K] Bjarne Stroustrup - Why you should avoid Linked Lists-YQs6IC-vgmo.mp4
[K] Branchless Programming in C++ - Fedor Pikus - CppCon 2021-gbQbPNqf9ik.mp4
  - it is HARD
[D] Breaking Dependencies - The SOLID Principles - Klaus Iglberger - CppCon 2020-Ntraj80qN2k.mp4
[D] Building an Extensible Type Serialization System Using Partial Template Specialization - CppCon 2021--2Sda1-03i8.mp4
[E] Building an Intuition for Composition - Sy Brand - CppCon 2020-AGRWRwi7rD0.mp4
  - Wikipedia match articals are just badly written
  - accumulate
  - monoid triple: data type, binary operator, identity element. It is for folding
  - operator| to compose, like max_element(sessions, order_by(&session::date) | orderby(&session::title))
  - transform -> map -> fmap
  - functor
  - optional.and_then
  - parser
  - monad for buidling pipe lines, for composing operations within context
  - static exceptions like rust::Result
[K] C++ Class Natures - Peter Sommerlad - Meeting C++ Secret Lightning Talks-I3WC8jXI8ek.mp4
  - value types just work, no virtual
  - assignment operators should be ref qualified by `&` to prevent assigning to a temporary
  - DesDeMovA (Rule of Destructor defined Deleted Move Assignment)
  - Scoped Manager
    ```cpp
    class T {
      Resource resource;
    public:
      T();
      ~T();
      T& operator=(T&&) = delete;
    };
    ```
  - Unique Manager
    ```cpp
    class T {
      std::optional<Resource> resource;
      void release() noexcept {
        if (resource) {
          resource.reset();
        }
      }
    public:
      T() = default;
      explicit T(Params p);
      T::T(T &&other) noexcept : resource(std::move(other.resource)) {
        other.resource.reset();
      }
      ~T() noexcept;
      T& operator=(T&& other) & noexcept {
        this->release();
        std::swap(this->resource, other.resource);
        return *this;
      }
    };
    ```
  - Shared Manager, DON'T
  - Manager as Value
    ```cpp
    class T {
    public:
      T() = default;
      ~T();
      T(T&& other) noexcept;
      T(const T& other);
      T& operator=(T&& other) & noexcept;
      T& operator=(const T& other) &;
    };
    ```
[K] C++ Concepts and Ranges - Mateusz Pusz - Meeting C++ 2018-pe05ZWdh0N0.mp4
  - `typename T` and `auto&& t` is `void *` of c++
  - comprehensive, prove of c++ is a mess, don't use it
[K] C++ Function Templates - How Do They Really Work - Walter E. Brown [C++ on Sea 2019]-nfIX8yWlByY.mp4
  - no ctors, dtors, assign ops ever arises from template functions
[D] C++ Russia 2018 -  Andrei Alexandrescu, Expect the expected-CGwk3i1bGQI.mp4
[E] C++ STL best and worst performance features and how to learn from them - Danila Kutenin [ C++onSea ]-GRuX31P4Ric.mp4
  - outsanding types/containers: array, optional, variant, atomic, span, string_view, <algorithm>
  - debatable types/containers: vector, string, set, map
  - bad types/containers: tuple, pair, unordered_*, regex
  - std::array is_trivially_copable if T is. rule of zero
  - if possible, make type trivial
    - trivially destructible types can reuse object
    - trivially copyable object can be mem*
    - better optimized, like optional is trivial if T is trivial
  - ABI
  - libc++, new standard are better
[T] C++ and Beyond 2012 - Herb Sutter - atomic Weapons 1 of 2-A8eCGOqgvH4.mp4
[T] C++ and Beyond 2012 - Herb Sutter - atomic Weapons 2 of 2-KeLBd2EJLOU.mp4
[D] C++11_14 at Scale - What Have We Learned - John Lakos & Vittorio Romeo - [CppNow 2021]-E3JG2Ijjei4.mp4
[K] C++17  - The Biggest Traps - Nicolai Josuttis [C++ on Sea 2019]-mAZyaAo3M70.mp4
  - what can I say about c++, sigh
[K] C++20 - My Favourite Code Examples - Nicolai Josuttis [ C++ on Sea 2021 ]-qdSAPQiRBDo.mp4
  - tick-tock messageing hierarchy, from inheritence to concept
[K] C++20 Concepts - A Day in the Life - Saar Raz - CppCon 2019-qawSiMIXtE4.mp4
  - inheritence tick-tock messaging -> compile time concept
[E] C++20 Concepts - Andreas Fertig - ACCU 2022 [XOMv4VilN50].mp4
  - practical usage
  - simplify std::optional with concept
[K] C++20 Ranges in Practice - Tristan Brindle - CppCon 2020-d_E-VLyUnzc.mp4
  - borrowed_range / dangling iterator
[D] C++20 STL Features - One Year of Development on GitHub - Stephan T. Lavavej - CppCon 2020-8kjRx8vo6y4.mp4
  - cmp_less / in_range
  - constexpr for static_assert(is_sorted)
[D] C++20 - The Small Pearls - Rainer Grimm - ACCU 2022 [OLRXMgXtprQ].mp4
[D] C++Now 2017 - Bryce Lelbach “Multidimensional Iterators”-EVGenON6p9g.mp4
[D] C++Now 2017 - Daniel Pfeifer “Effective CMake'-bsXLMQ6WgIk.mp4
[K] C++Now 2017 - Jason Turner '(Ab)using C++17'-AqDsso3S5fg.mp4
  - for_each_argument
  - deduction guide
  - variant vs virtual, virtual is better?
[K] C++Now 2017 - Jon Kalb “Modern C++ Coming to Terms With Terms'-14dJ4XRuDEk.mp4
[T] C++Now 2017 - Jonathan Beard “Good FIFOs Make Good Thread Neighbors'-pvp-QQD0Xx0.mp4
  - lots of hardware stuff
[E] C++Now 2017 - Jonathan Müller “Type-safe Programming'-iihlo9A2Ezw.mp4
  - If you pass a sequence of parameters which are not going to do the right thing, get the type system to reject it.
    Use the type system to encourage people to write calls which are almost certainly going to work
  - operator bool() -> optional
  - enum state -> variant
[D] C++Now 2017 - M. Skarupke “Sorting in less than O(n log n) - Generalizing and optimizing radix sort'-zqs87a_7zxw.mp4
[D] C++Now 2017 - Mark Zeren “Rethinking Strings'-OMbwbXZWtDM.mp4
[K] C++Now 2017 - Marshall Clow “The 'Detection idiom -' A Better Way to SFINAE'-U3jGdnRL3KI.mp4
[D] C++Now 2017 - Peter Bindels 'Mocking C++'-t0wLm2iiEH0.mp4
  - object memory layout
  - name mangling
  - his c++ code is behavior undefined
[K] C++Now 2017 - Vittorio Romeo “You must type it three times”-I3T4lePH-yA.mp4
  - decltype(expr) foo(F&&f, Ts...ts) noexcept(noexcept(expr)) { reutrn expr; }
  - expr is std::forward<F>(f)(std::forward<Ts>(ts)...)
  - decltype(full_expr) instead of decltype(auto) to be SFINAE friendly
[E] C++Now 2018 - Alan Talbot “Moving Faster - Everyday Efficiency in Modern C++”-J9yVA341zrw.mp4
  - Most program do not spend 59% of their time on 5% of their code
  - don't pay attention to performance may end up with a big slow program.
  - avoid cache misses
  - avoid allocations
  - pass by value if it is simple / copy needs to be modified
  - pass by const ref, even shared_ptr, or in generic code. No penalties for built-in types
  - pass by ref, generally avoid this, makes code hard to understand, unless it is for avoiding re-allocation
  - move
  - emplace
      ```cpp
      vector<string> v;
      auto& s = v.emplace("hello");
      s += ",",
      s += "world",
      ```

      ```cpp
      class Bar {
        vector<Foo> foo;
      public:
        template <typename... T>
        void add(T&& ...t) {
          foo.emplace_back(forward<T>(t)...);
        }
      };

      Bar b;
      b.add(1, 3.5, "hello");
      ```

      ```cpp
      v.emplace_back().read(file)
      ```
  - various standard containers for querying/insertion
[A] C++Now 2018 - Arthur O'Dwyer “An Allocator is a Handle to a Heap”-0MdSJsCTRkY.mp4
[K] C++Now 2018 - Ben Deane “Easy to Use, Hard to Misuse - Declarative Style in C++”-2ouxETt75R4.mp4
  - builder by bitset
[A] C++Now 2018 - David Sankel “C++17's std - -pmr Comes With a Cost”-FLbXjNrAjbc.mp4
[E] C++Now 2018 - Jason Turner “Initializer Lists Are Broken, Let's Fix Them”-sSlmmZMFsXQ.mp4
  - std::initializer_list is an view to a temporary/hidden array. Do not return it from a function
  - vs emplace_back
  - make_move_iterator
  - should be deprecated
[A] C++Now 2018 - Jon Kalb “This is Why We Can't Have Nice Things'-fovPSk8ixK4.mp4
  - east vs west const
  - If you must remain consistant with the past, you can never improve
[D] C++Now 2018 - Louis Dionne “Runtime Polymorphism - Back to the Basics”-OtU51Ytfe04.mp4
  - reference semantics, lose the ability to copy
  - possible heap allocation, then object can be nullable, and ownership problem
  - doesn't play well with algorithms
  - type erasure + manually vtable
  - small object optimization
  - never allocated inplace_function and function_ref
[A] C++Now 2018 - Matt Godbolt “What Else Has My Compiler Done For Me Lately”-nAbCKa0FzjQ.mp4
  - make function body visible to enable optimization
  - __attribute__((pure))
  - aliasing
  - std::max better than if then assign, ternary operator is good than branching
  - heap elision
  - devirtualize functions
[A] C++Now 2018 - Michael Caisse “Modern C++ in Embedded Systems”-c9Xt6Me3mJ4.mp4
  - very funny
  - most of the embeded world hates c++
  - boost::sml for state machine
[D] C++Now 2018 - Odin Holmes “C++ Mixins - Customization Through Compile Time Composition”-wWZi_wPyVvs.mp4
[E] C++Now 2018 - You Can Do Better than std - -unordered_map - New Improvements to Hash Table Performance-M2fKMP47slQ.mp4
  - < 400 elements, std::map faster than std::unordered_map
  - linear search is better than std::map for the first 15, still better than std::unordered_map around 150
  - reduce the time from hash() to equal_to(); modulo is slow, is possible using binary and
  - reduce cache misses; open addresing by using a flat array
  - reduce unnecessary comparasons
  - have to use link list in arrays, if pointers have to be stable. just need to handle empty slots
  - robin hood hashing
[D] C++Now 2019 - Arvid Norberg “The ABI challenge”-ncyQAjTyPwU.mp4
[E] C++Now 2019 - Chandler Carruth “A clean and minimal map API”-kye4aD-KvTU.mp4
  - lookup/remove/update/insert
  - []/contains/begin/end
  - small size optimization
  - view/ref
[A] C++Now 2019 - John Lakos “Value Proposition - Allocator-Aware (AA) Software”-dDR93TfacHc.mp4
[D] C++Now 2019 - Timur Doumler “Better CTAD for C++20”-7LPQWqAZZqs.mp4
[D] CMake + Conan - 3 Years Later - Mateusz Pusz - [CppNow 2021]-mrSwJBJ-0z8.mp4
[E] CPU design effects -  Jakub Beránek - Meeting C++ 2019-ICKIMHCw--Y.mp4
  - frontend: loading/decoding instructions from memory, add to buffer
  - backend: executing/store to memory
  - branch prediction on (un)sorted array, different element types have different behavior
  - cpu pipeline
  - N-way set associative, address hashing, l1d.replacement for this metric
  - denormal floating point numbers, fp_assistant.any for this metric, -ffast-math, Flush-to-zero and Denormals-to-zero for cpu flags
  - false sharing, l2_rqsts.all_rfo for this metric
[D] Calling Functions - A Tutorial - Klaus Iglberger - CppCon 2020-GydNMuyQzWo.mp4
  - when which gets called
[E] Chandler Carruth - Programming Language Design for Performance Critical Software-_prA_EmoBe4.mp4
  - no hot inner loop - profiles are flat
  - why c++ is designed like this
  - why data race is UB and no gc
  - coroutines doens't fit in this phylosophy, memory allocation is out of user control
  - std::unique_ptr is buggy, cannot be fitted in a register, cannot be fixed due to ABI breakage
  - exception hurts control and predicibility of the program/compiler
  - rust problem?
[E] Choosing the Right Integer Types in C and C++ - Dan Saks - code - -dive 2018-IJaa58cfvOw.mp4
  - binary operaion rule
    1. *promote* each operand with a rank lower than *int* to either *int* or *unsigned int*
    2. *convert* the operand with lower rand to the higher rank
    3. within the same rank, compiler is in favor of unsigned type
  - use int8_t when you need *exact* size
  - use int_least8_t when you need *portability*
  - use int_fast8_t when you need *portability* and *performance*
[D] Code smells on hot paths - Mateusz Nowak - Meeting C++ online-1ko4fhByXVE.mp4
  - .at should be prefered comparing to operator[] for map
  - if need continuous memory or known size in runtime then use vector, otherwise deque
  - minimize private methods, using free functions within anonymous namespace to help optimization
[K] Coffee Compiler Club, 2020_07_31-kKzBbKRXhQM.mp4
  - performance monitoring counters
  - HOW-TO perf
[T] Concurrency and the C++ Memory Model-NZ_ncor_Lj0.mp4
[D] Conquering C++20 Ranges - Tristan Brindle - CppCon 2021-4cYru2YKBxA.mp4
[A] Cool New Stuff in Gdb 9 and Gdb 10 - Greg Law - CppCon 2021-xSnetY3eoIk.mp4
  - readelf --sesions, add -W to get wider display
  - separating debuginfo
    1. objcopy --only-keep-debug a.out a.out.dbg
    2. objcopy --add-gnu-debug-link=a.out.dbg a.out
  - debuginfod to serve debuginfo via network; DEBUG_INFOD_URLS=server:port gdb a.out
  - readelf --notes a.out | grep Build, to get build id
  - define-prefix/define to create user defined commands
  - | as pipe in (gdb) | CMD | shell
  - set print frame-arguments all | none | presence | scalars
  - set print frame-info auto | location | location-and-address | short-location | source-and-location | source-line
  - ptype /o type, gives offset and size of members of a struct. /x to get those data in hex
  - compile command to set blocks of hand written code
[A] Core C++ 2019  - - Dan Saks  - - Understanding Lvalues and Rvalues-mK0r21-djk8.mp4
[D] Core C++ 2019  - - Gal Zaban  - - Behind Enemy Lines - Reverse Engineering C++ in Modern Ages-BpsD08mBMK8.mp4
[E] Core C++ 2019  - - Nimrod Sapir  - - High Frequency Trading and Ultra Low Latency development techniques-_0aU8S-hFQI.mp4
  - within 1 microsecond, and light travels 300m/microsecond, must inside exchange
  - kernel bypass, syscalls are too slow
  - avoid context switching
  - deterministic, static code flow, complile time execution as much as possible
  - minimize cache misses and wrong branch predictions
    - warm up. Don't `if` on cache warming
    ```cpp
    std::array<size_t, 2> g_total_value{};
    void add_order_value(Order& order) {
      g_total_value[order.is_warming] += order.get_amount() * order.get_price();
    }
    size_t get_order_value() { return g_total_value[false]; }
    ```
  - customized data structure
    - for 20 items, binary search on sorted array is much faster than std::map, 2us vs 25us
[D] Core C++ 2019  - - Timur Doumler  - - Initialisation in modern C++-v0jM4wm1zYA.mp4
[D] Core C++ 2021  - - opt-viewer - Inspecting compiler optimizations in high-level code-BJ_yxTmZQbc.mp4
[E] Correct by Construction - APIs That Are Easy to Use and Hard to Misuse - Matt Godbolt [ C++ on Sea ]-nLSm3Haxz0I.mp4
  - force correct type
    ```cpp
    template <typename T> explicit quantity(T quantity) : quantity_(quantity) {
      static_assert(std::is_unsigned_v<T>, "");
    }
    ```
  - operator""_qty
  - different types for builder, use && ref-qualifier to forcefully eliminate temporates
    ```cpp
    struct Step1 {
      [[nodiscard]] Step2 foo() &&;
    };
    ```
[D] Counting Nanoseconds Microbenchmarking C++ Code - David Gross - Meeting C++ 2019-Czr5dBfs72U.mp4
  - rdpmc
[E] CppCon 2014 - Andrei Alexandrescu 'Optimization Tips - Mo' Hustle Mo' Problems'-Qq_WaiwzOtI.mp4
  - inlining is everything, --max-inline-instns-auto=100 --early-inlining-instns=200, regression from 4.7 to 4.8, 7% performance difference
  - customized shared_ptr
    - using pointer bits as ref counter. log and leak if it's full
    - "zero" optimization. when ref counter is nullptr, then there is one object
    - goto
    - alloc/free should keep meta data from payload
[E] CppCon 2014 - Chandler Carruth 'Efficiency with Algorithms, Performance with Data Structures'-fHNmRkzxHWs.mp4
  - the fast your software runs, the less power it consumes
  - java is "faster" than c++
  - efficiency throught algorithms, improving effciency involves doing less work
  - performance throught data structures, improving performance involves doing work faster
  - discontiguous data structures are the root of all (performance) evil
  - if a queue has a total upper bound, can use a std::vector, grow it forever, chase the tail with the index, and never remove it from front
  - std::deque has the worst api
  - map
  - bubble sort is best for small date set, like < 64 numbers
  - binary search on sorted vector vs map
[E] CppCon 2014 - Herb Sutter 'Back to the Basics! Essentials of Modern C++ Style'-xnqTKD8uD64.mp4
  - return types / passing parameters by value/ref/pointer
  - smart pointers
    - sink(unique_ptr)
    - reseat(unique_ptr&)
    - xxxx(const unique_ptr&)
    - share(shared_ptr) // will be copied
    - reseat(shared_ptr&)
    - may_share(const shared_ptr&)
  - using "Pin" using unaliased local copy to solve the reentrancy pitfall
  - for setters
  ```cpp
  void set_name(const std::string&);
  void set_name(std::string&&) noexcept;
  ```
[T] CppCon 2014 - Herb Sutter 'Lock-Free Programming (or, Juggling Razor Blades), Part I'-c1gO9aB9nbs.mp4
[T] CppCon 2014 - Herb Sutter 'Lock-Free Programming (or, Juggling Razor Blades), Part II'-CmxkPChOcvw.mp4
[D] CppCon 2014 - Kostya Serebryany 'Sanitize your C++ code'-V2_80g0eOMc.mp4
  - implementations of sanitizers
[E] CppCon 2014 - Mike Acton 'Data-Oriented Design and C++'-rX0ItVEVjHc.mp4
  - NO exceptions, templates, iostream, multiple inheritance, operator overloading, RTTI, stl
  - custom allocators
  - three lies
    1. software is a platform. Hardware IS the platform
    2. code designed around model of the world. Design around the DATA, not an idealized world
    3. code is more importand than data. DATA -> transform -> DATA. Your main responsibility is to transform DATA, solve that first, not the code design
  - understand the data, you understand the problem
  - There is no ideal, abstract solution to the problem
  - Solve for trasforme the data you have, Given the constraints of the plat form, and nothing else
  - hash table, split key and value
  - NO bool in structs
  - information density
  - Rule of thumb: Store each state type separately, store same states together, no state value needed
  - "Design patterns are spoonfeed material for brainless programmers incapable of independent thought, who will be resolved to producing code as mediocre as the design patterns they use to create it."
[E] CppCon 2014 - Scott Meyers 'Type Deduction and Why You Care'-wQxj20X-tIU.mp4
  - print types by error messages
  - decltype(lvalue expr of type T) == T&
[D] CppCon 2014 - Titus Winters 'The Philosophy of Google's C++ Code'-NOCElcMcFik.mp4
  - codebase is not exception safe
[E] CppCon 2014 - Walter E. Brown 'Modern Template Metaprogramming - A Compendium, Part I'-Am2is2QCvxY.mp4
[E] CppCon 2014 - Walter E. Brown 'Modern Template Metaprogramming - A Compendium, Part II'-a0FliKwcwXE.mp4
  - you rock!
[D] CppCon 2014 - Zach Laine 'Pragmatic Type Erasure - Solving OOP Problems w_ Elegant Design Pattern'-0I0FD3N5cgM.mp4
  - for inheritance, you need to read lots of code to know what to do, like whether calling base function
  - std::ref
  - COW
  - SBO
  - boost.type_erasure
  - github emtypen to generate his version of TE
[E] CppCon 2015 - Andrei Alexandrescu “Declarative Control Flow'-WjTrfoiB0MQ.mp4
  - copy a file in transaction
  - __COUNTER__ is unique, ODR violation?
[E] CppCon 2015 - Bryce Adelstein-Lelbach “Benchmarking C++ Code'-zWxSZcpeS8Q.mp4
  - math on this topic
[E] CppCon 2015 - Chandler Carruth 'Tuning C++ - Benchmarks, and CPUs, and Compilers! Oh My!'-nXaxk27zwlk.mp4
  - google bench
  - `perf record -g ./a.out` with `-fno-omit-frame-pointer`
  - `perf report -g` to get the graph of callee
  - `perf report 'graph,0.5,caller'` to get the graph of caller
  - "weird" total percentage, std::vector
  - modulo
[D] CppCon 2015 - David Sankel “Functional Design Explained”-x9mIAT-CAwA.mp4
[T] CppCon 2015 - Fedor Pikus PART 1 “Live Lock-Free or Deadlock (Practical Lock-free Programming)'-lVBvHbJsg5Y.mp4
[T] CppCon 2015 - Fedor Pikus PART 2 “Live Lock-Free or Deadlock (Practical Lock-free Programming) ”-1obZeHnAwz4.mp4
[A] CppCon 2015 - Fedor Pikus “C++ Metaprogramming - Journey from simple to insanity and back'-CZi6QqZSbFg.mp4
  - traditional ways to do practical programming
[D] CppCon 2015 - Fedor Pikus “The Unexceptional Exceptions'-fOV7I-nmVXw.mp4
  - rethrow dispatcher
  - pthread_cancel, GLibC implements that as an exception
  ```cpp
  try {
    something();
  } catch (abi::__forced_unwind&) {
    throw; // don't mess with pthread_cancel
  } catch (...) {
  }
  ```
  - but pthread_cancel can throw in any cancellation point, like destructors open files, noexcept functions
  - avoid pthread_cancel
[D] CppCon 2015 - Kyle Markley 'Extreme Type Safety with Opaque Typedefs'-jLdSjh8oqmE.mp4
  - address and offset operations
[T] CppCon 2015 - Michael Wong “C++11_14_17 atomics and memory model...'-DS2m7T6NKZQ.mp4
[D] CppCon 2015 - Neil MacIntosh “Evolving array_view and string_view for safe C++ code'-C4Z3c4Sv52U.mp4
[E] CppCon 2015 - Sean Parent 'Better Code - Data Structures'-sWgDk-o-6ZE.mp4
  - lg1,000,000,000,000 = 40, locality has more impact on performance than big O
  - how to write a stable_partition
    ```cpp
    template <typename I, typename P>
    auto stable_partition(I f, I l, P p) -> I {
      auto n = l - f;
      if (n == 0) return f;
      if (n == 1) return f + p(*f);

      auto m = f + (n/2);

      return rotate(stable_partition(f, m, p),
                    m,
                    stable_partition(m, l, p));
    }
    ```
    - nth_element to sort part of a container, nth_element also partitions all elements
    ```cpp
    template <typename I>
    void sort_subrange(I f, I l, I sf, I sl) {
      if (sf == sl) return;
      if (sf != f) {
        nth_element(f, sf, l);
        ++sf;
      }
      partial_sort(sf, sl, l);
    }
    ```
  - hierarchies on tree
[D] CppCon 2015 - Stephan T. Lavavej “functional - What's New, And Proper Usage'-zt7ThwVfap0.mp4
[D] CppCon 2015 - T. Winters & H. Wright “All Your Tests are Terrible...'-u5senBJUkPc.mp4
[E] CppCon 2015 - Titus Winters 'Lessons in Sustainability...”-zW-i9eVGU_k.mp4
  - Your organization's codebase is **sustainable** when you are able to change **all** of the things that you ought to change, safely, and can do so for the lifetime of your codebase.
  - testing (is this change safe)
  - policies (mitigate the crazy)
  - technology (automation and awareness)
  - practice, practice, practice
[D] CppCon 2015 - Zach Laine 'Writing Great Libraries - 89 Easy Steps'-hcHUZE6buzE.mp4
[D] CppCon 2015 -Marshall Clow “Type Traits - what are they and why should I use them'-VvbTP_k_Df4.mp4
[D] CppCon 2016 - Arno Lepisk “On using singletons in C++'-23xDn3ReH7E.mp4
  - put singleton in namespace instead of using class, like my logger
[D] CppCon 2016 - Arthur O'Dwyer “Template Normal Programming (part 1 of 2)”-vwrXHznaYLA.mp4
[D] CppCon 2016 - Arthur O'Dwyer “Template Normal Programming (part 2 of 2)'-VIz6xBvwYd8.mp4
[D] CppCon 2016 - Ben Deane “A Static Alternative to Virtual Functions, Using Expression SFINAE'-8jbt-5Qub9E.mp4
  - detection idiom
[E] CppCon 2016 - Ben Deane “Using Types Effectively'-ojZbFIQSdl8.mp4
  - type is the set of values that can inhabit an expression
  - make illegal states unrepresentable
  - phantom types to avoid invalid data
  ```cpp
  template <typename T> struct Data {
    explicit Data(const std::string& input);
    std::string input;
  };
  struct sanitized{};
  struct unsanitized{};

  Data<unsanitized> GetData();
  std::optioinal<Data<sanitized>> SanitizeData(const Data<unsanitized>&);
  T query(const Data<sanitized>&); // instead of using std::string everywhere, which might cause injection problem
  ```
  - total function is a function that is defined for all inputs in its domain
[E] CppCon 2016 - Chandler Carruth “Garbage In, Garbage Out - Arguing about Undefined Behavior...'-yG1OZ69H_-o.mp4
  - signed integer is the faster one
[E] CppCon 2016 - Chandler Carruth “High Performance Code 201 - Hybrid Data Structures'-vElZc6zSIXM.mp4
  - small size optimized vector, type erase the size
  ```cpp
  #include <cstddef>

  template <typename T> struct VectorBase {
      VectorBase(T* begin, T* end, std::size_t capacity) : begin_(begin), end_(end), capacity_(capacity) {}
      T* begin() const { return begin_; }
      T* end() const { return end_; }
  private:
      T* begin_ = nullptr;
      T* end_ = nullptr;
      std::size_t capacity_ = 0;
  };

  template <typename T, std::size_t N> struct Vector : VectorBase<T> {
      Vector() : VectorBase<T>(buffer_, buffer_ + N, N) {}
  private:
      T buffer_[N];
  };

  extern void bar(int);
  void foo(const VectorBase<int>& v) { for (const auto i : v) { bar(i); } }

  int main() {
      auto v1 = Vector<int, 30>();
      auto v2 = Vector<int, 7>();
      foo(v1);
      foo(v2);
  }
  ```
  - small dense set
  ```cpp
  template <tyname T, int N, typename Traits = DenseSetTraits<T>> struct SmallDenseSet {
    T* Bucksets;
    size_t Size, NumTombstones, BucketsSize;
    char Buffer[sizeof(T)*N];
  public:
    SmallDenseSet(): Buckets((T*)Buffer),Size(0), NumTombstones(0), BucketsSize(N) {}
  };
  template <typoename T> struct DenseSetTraits {
    static T getEmpty();
    static T getTombstone();
    static size_t getHash(const T&X);
    static bool compare(const T&LHS, const T&RHS);
  };
  ```
  - allocator doesn't work when crossing interface boundaries
  - how to make values small
    - give large objects address identity: address, even index, or using pointer's low bits
    - localized "malloc" arena
    ```cpp
    class BumpPtrAllocator {
      constexpr int SlabSize = 4096; // page size
      SmallVector<void *, 4> Slabs;
      void *CurPtr, *End;
    public:
      void *Allocate(int Size) {
        if (Size >= (End - CurPtr)) {
          CurPtr = malloc(SlabSize);
          End = CurPtr + SlabSize;
          Slabs.push_back(CurPtr);
        }
        void *Ptr = CurPtr;
        CurPtr += Size;
        return Ptr;
      }
    };
    ```
  - finally, a TinyPtrVector
  - If ordring is needed, where possbile, sort vectors
  - using vector for iteration
  ```cpp
  template <typename T, int N, typename VectorT =SmallVector<T, N>, typename  SetT=SmallDenseSet<T, N>> class SmallSetVector {
    SetT S;
    VectorT V;
  public:
    bool insert(const T &X) {
      bool Result = S.insert(X).second;
      if (Result) V.push_back(X);
      return Result;
    }
    VectorT::iterator begin() { return V.begine(); }
    VectorT::iterator end() { return V.end(); }
  };
  ```
  - std::deque is bad
  - trie is very unusal, maybe only one place in complier that it's used
[E] CppCon 2016 - Cheinan Marks “I Just Wanted a Random Integer!'-4_QO1nm7uJs.mp4
  - everything needs to know about ramdom stuff, practically
  - Use std::random_device to seed
  - Keep std::mt19937 off stack, it is huge(5KB), and expendsive to init
  - std::minstd_rand is smaller, but not really faster
  - PCG random generator by Melissa O'Neill, faster than std::mt19937
  - std::uniform_int_distribution inited in loop gets better performance
[E] CppCon 2016 - Dan Saks “extern c - Talking to C Programmers about C++”-D7Sd8A6_fYU.mp4
  - If you're arguing, you're losing
  - No matter how it looks at first, it's always a people problem -- Gerald Weinberg: The secrets of consulting
  - People make personal, and professional, decisions based largly on emotional rather than rational factors
  - "In this world, Elwood, you must be oh so smart or oh so pleasant." Well, for years I was smart. I recommend pleasant. You may quote me.
  - post hoc reasoning, motivated cognation: Make gut-level decisions, and use our interllect to justify those decisions
  - fear of loss > desire of gain
  - data type: size and alignment, set of valid values, set of permitted operations
  - social media is for enforcing your believes
[E] CppCon 2016 - David Sankel “Building Software Capital - How to write the highest quality code and why'-ta3S8CRN2TM.mp4
  | technical debt         | software capital       |
  |------------------------|------------------------|
  | easy to create         | hard to create         |
  | cheap                  | expensive              |
  | narrow focus           | wide focus             |
  | resued "by the gun"    | voluntarily resued     |
  | ugly                   | beautiful              |
  | incomplete             | complete               |
  | increase time to market| decrease time to market|
  1. code review
  2. standard, tooling is a must
  3. unit testing, design for testability
  4. contracts, the code is the documentation doesn't work for large project. BDE contract specification
  7. infrastructure
  - paying the innovation tax
    1. training: conferences, books, code reviews
    2. modernizing the code base: a priority, automation can help a lot
[D] CppCon 2016 - David Watson “Experiences with Facebook's C++ library'-GDxb21kEthM.mp4
[D] CppCon 2016 - Diego Rodriguez-Losada “Conan, a C and C++ package manager for developers'-xvqH_ck-5Q8.mp4
[T] CppCon 2016 - Fedor Pikus “The speed of concurrency (is lock-free faster)'-9hJkWwHDDxs.mp4
[E] CppCon 2016 - Herb Sutter “Leak-Freedom in C++... By Default.”-JfmTagWcqoE.mp4
  - unique_ptr
    - as lazy something
    - pimpl idiom
        ```cpp
        template <typename T> using Piml = const unique_ptr<T>;
        class MyClass {
          class Impl;
          Piml<Impl> piml;
        };
        ```
    - fixed-but-dyanmic-size array, unique_ptr<Data[]>
    - Tree, but out of stack
        ```cpp
        class Tree {
          struct Node {
            vector<unique_ptr<Node>> children;
            Node *parent;
          };
          unique_ptr<Node> root;
        };

        void release_subtree(unique_ptr<Node> n) {
          while (n->children.size() > 0) {
            auto leaf = &n->children;
            while (leaf[0]->children.size() > 0) {
              leaf = &leaf[0]->children;
            }
            leaf.pop_front();
          }
        }
        ```
    - Tree that hands out strong refs, aliasing constructor
        ```cpp
        class Tree {
          struct Node {
            vector<shared_ptr<Node>> children;
            Data data;
          };
          shared_ptr<Node> root;
          shared_ptr<Data> find(/*..*/) {
            /*..*/ return {spn, &(spn->data)};
          } // note: using shared_ptr aliasing contrustor
        };
        ```
    - DAG
        ```cpp
        class DAG {
          struct Node {
            vector<shared_ptr<Node>> children;
            vector<Node *> parents;
          };
          vector<shared_ptr<Node>> roots;
        };
        ```
    - Factory + cache, favorate sub-10 lines program
        ```cpp
        shared_ptr<widget> make_widget(int id) {
          static map<int, weak_ptr<widget>> cache;
          static mutex mut_cache;
          lock_guard<mutex> hold(mut_cache);
          auto sp = cache[id].lock();
          if (not sp) cache[id] = sp = load_widget(id);
          return sp;
        }
        ```
    - Circular list
        ```cpp
        class CircularList {
          class Node {
            unique_ptr<Node> next;
            unique_ptr<Node> &head;
          public:
            auto get_next() { return next ? next.get() : head.get(); }
          };

          unique_ptr<Node> head;
        };
        ```
    - possible circular graph, and how to find circle in a graph
        ```cpp
        class Graph {
          struct Node {
            vector<Node *> children;
            vector<Node *> parents;
            /* data */
          };
          vector<Node *> roots;
          vector<unique_ptr<Node>> nodes;
        };
        ```
    - garbage collection in c++
[E] CppCon 2016 - Howard Hinnant “A ＜chrono＞ Tutorial'-P32hvk8b13M.mp4
  - very fast, very simple
      ```cpp
      class seconds {
        int64_t sec_;
      public:
        seconds() = default;
        //etc.
      };

      seconds s{3};
      cout << s.count() << "s\n"; // 3s, value for int64_t
      ```
  - no implicit path from int to seconds
      ```cpp
      void f(seconds d);

      f(3); // error
      ```
  - for not loss-less conversion, druation_cast is needed
      ```cpp
      seconds x = 3400ms; // error, lose precision
      seconds y = druation_cast<seconds>(3400ms); // 3s
      ```
  - using 32bit instead of 64bit, `using seconds32 = duration<int32_t, second>`, or other int-like custom types
  - duration
      ```cpp
      template <intmax_t N, intmax_t D = 1> class ratio {
        static constexpr intmax_t num;
        static constexpr intmax_t den;
        using type = ratio<num, den>;
      };

      template <class Rep, class Period = ratio<1>> class duration {
      public:
        using rep = Rep,
        using period = Period;
        // ...
      private:
        Rep rep_;
      };
      ```
  - generialized duration unit
      ```cpp
      using frames = duration<int32_t, ration<1, 60>>; // 1/24 seconds

      void f(duration<float, milli> d);

      f(frames{1}); // 16.6667ms, 1/60 second
      f(45ms + frames{5}); // 128.333ms

      // for the latter example,
      // pseudo syntax
      //   45   [int64_t, 1/1000] + 5    [int32_t, 1/60]
      // find common_type and convert to it
      //   45*3 [int64_t, 1/3000] + 5*50 [int32_t, 1/3000]
      // do arithmetic in common_type
      //   358  [int64_t, 1/3000]
      // convert to duration<float, milli>
      //   128.333 [float, 1/1000]
      ```
      ```cpp
      using days = duration<int, ration_multiply<ration<24>, hours::period>>;
      // same thing
      using days = duration<int, ration<86400>>;
      ```
  - clocks
    - system_clock, when you need time_points that must relate to some calendar
    - steady_clock, when you need a stopwatch, good for timing, but cannot give you the time of day
    - high_resolution_clock is an alias to one of above, don't use this, use more explicit one
  - timing
      ```cpp
      auto t0 = steady_clock::now();
      f();
      auto t1 = steady_clock::now();
      cout << nanoseconds{t1-t0}.count() << "ns\n"; // 135169457ns
      cout << duration<double>{t1-t0}.count() << "s\n"; // 0.135169s
      cout << duration_cast<milliseconds>(t1-t0).count() << "ms\n"; // 135ms
      ```
  - mutex timed try lock
      ```cpp
      std::mutex mut;
      if (mut.try_lock_for(500ms))
        //...
      if (mut.try_lock_until(steady_clock::now() + 500ms))
        //...
      ```
  - time since epoch
      ```cpp
      auto tp = time_point_cast<seconds>(system_clock::now());
      cout << tp.time_since_epoch().count() << "s\n"; // 1469456123s

      auto td = time_point_cast<days>(system_clock::now());
      cout << tp.time_since_epoch().count() << "days\n"; // 17007days
      ```
[E] CppCon 2016 - Jason Turner “Practical Performance Practices'-uzF4u9KgUWI.mp4
  - Use IIFE, 31% more efficient
  - C++ Core guidline state that const methods should be thread safe
  - Rule of zero, 10% more efficient
  - avoid named temporaries
  - avoid shared_ptr copies
      ```cpp
      int use_a_base(const std::shared_ptr<Base> &p) { return p->value(); }

      int main() {
        auto ptr = std::make_shared<Derived>();
        use_a_base(ptr); // a temporary shared_ptr<Base> will be created
      }
      ```
  - std::endl causes 9x overhead in IO
  - move as many code as possible from template, detemplatizing
  - prefer return unique_ptr from factories, even sahred_ptr is needed
  - std::function + std::bind is 2.9x slower than bare function call
  - std::bind is 1.9x slower than bare function call
  - lambda has zero overhead compare to direct function call
  - cosntexpr is_sorted is the same as none constexpr version
  - constexpr might result in bigger code, bigger code is often slower code
  - if you enable constexpr, make sure you go all the way
  - final can help th ecompiler optimize virtual function calls
[E] CppCon 2016 - Jon Kalb “unsigned - A Guideline for Better Code'-wvtFGa6XJDU.mp4
  - Don't do math on unsigned types
  - Don't use "unsigned" for quntities
  - using unsigned is a good way to hide bugs in your code. You can't verify that you aren't using a negative value by mistake
[D] CppCon 2016 - Marshall Clow “STL Algorithms - why you should use them, and how to write your own'-h4Jl1fk3MkQ.mp4
  - copy_with, split, adjacent_pair, for_all_pairs
  - dispatch on iterator category
[E] CppCon 2016 - Michael Spencer “My Little Optimizer - Undefined Behavior is Magic'-g7entxbQOCc.mp4
[E] CppCon 2016 - Nicholas Ormrod “The strange details of std - -string at Facebook'-kPR8h4-qZdk.mp4
  - COW string using refcount-1 to get zero for default to eliminate extra ops
  - how to get 22+1 bytes SSO
[T] CppCon 2016 - Pablo Halpern “Introduction to Vector Parallelism'-h6Q-5Q2N5ck.mp4
[E] CppCon 2016 - Tim Haines “Improving Performance Through Compiler Switches...'-w5Z4JlMJ1VQ.mp4
[D] CppCon 2016 - Tommy Bennett “Algorithm Mnemonics - Increase your Productivity with STL Algorithms'-tSq7yDwS1vM.mp4
[D] CppCon 2016 - Walter E. Brown “What C++ Programmers Need to Know about Header ＜random＞'-6DPkyvkMkk8.mp4
  - engine is a means of obtaining a sequence of (ideally) unpredictable bits that are uniform
  - distribution is a means of obtaining variates (value of desired aggregated shape) from such a sequence of bits
  ```cpp
  #include <random>
  int roll_a_fair_die() {
    static std::default_random_engine e{};
    static std::uniform_int_distribution<int> d{1, 6};
    return d(e); // obtain a random variate
  }
  ```
  - don't use e()%6 + 1
    - 2^n isn't evenly divisible by 6. "It's the pigeonhole principle: if you have 2^32 pigeons, ... you can't put them into [6] pigeonholes without having more pigeons in some holes than others."
    - a floating-point variation is "Hilariously non-uniform"
  - serialize access or thead_local the engine, it is stateful and mutable
[E] CppCon 2017 - Arthur O'Dwyer “A Soupçon of SFINAE”-ybaE9qlhHvw.mp4
  - fancy template stuff
[A] CppCon 2017 - Bob Steagall “How to Write a Custom Allocator”-kSWfushlvB8.mp4
[E] CppCon 2017 - Carl Cook “When a Microsecond Is an Eternity - High Performance Trading Systems in C++”-NH1Tta7purM.mp4
  - no hyper threading
  - don't share L3, disable all but 1 core, or lock the cache
  - if you do have multiple cores enabled, choose your neighbours carefully
    - noisy neighbours should probably be moved to a different physical CPU
  - slowpath removal, light travels at 1 foot/nS, about 0.3 meters
      ```cpp
      if (checkForErrorA())
        handleErrorA();
      else if (checkForErrorB())
        handleErrorB();
      else if (checkForErrorC())
        handleErrorC();
      else
        sendOrderToExchange();

      // v.s. 100~200 ns faster

      int64_t errorFlags = 0;
        //...
      if (!errorFlags)
        sendOrderToExchange();
      else
        handleError(errorFlags);
      ```
  - virtual is fine if don't know all possibilities, otherwise use template-based configuration
      ```cpp
      struct OrderStructA { void SendOrder(); };
      struct OrderStructB { void SendOrder(); };

      template <typename T> struct OrderManager : public IOrderManager {
        void MainLoop() final { mOrderSender.SendOrder(); }
        T mOrderSender;
      };

      std::unique_ptr<IOrderManager> Factory(const Config& config) {
        if (config.UserOrderSenderA())
          return std::make_unique<OrderManager<OrderStructA>>();
        else
          return std::make_unique<OrderManager<OrderStructB>>();
      }

      int main() {
        auto manager = Factory(config);
        manager->MainLoop();
      }
      ```
  - reuse objects instead of deallocating
    - delete involves no system calls, but glic free has 400 lines of book-keeping code
    - reusing avoid memory fragmentation as well
    - if must delete large objects, consider doing this from another thread
  - exceptions are zero cost if they don't throw. Thrown at cost of 1.5us
  - prefer templates to branches
      ```cpp
      enum class Side {Buy, Sell};

      void RunStrategy(Side side) {
        const float orderPrice = CalcPrice(side, fairValue, credit);
        CheckRiskLimits(side, orderPrice);
        SendOrder(side, orderPrice);
      }

      float CalcPrice(Side side, float value, float credit) {
        return side == Side::Buy ? value - credit : value + credit;
      }

      // v.s.

      template <Side T>
      void Strategy<T>::RunStrategy() {
        const float orderPrice = CalcPrice(fairValue, credit);
        CheckRiskLimits(orderPrice);
        SendOrder(orderPrice);
      }

      template <>
      float Strategy<Side::Buy>::CalcPrice(float value, float credit) {
        return value - credit;
      }

      template <>
      float Strategy<Side::Sell>::CalcPrice(float value, float credit) {
        return value + credit;
      }
      ```
  - multithreading is best avoided for latency-sensitive code
    - synchronization of data via locking will get expensive
    - lock free code may still require locks at the hardware level
    - mind-bendingly complex to correctly implement parallelism
    - easy for the producer to accidently saturate the consumer
  - if multithreading is a must
    - keep shared data to an absolute minimum
    - passing copies rather than sharing data, e.g. a single writer, single reader lock free queue
  - denormalized data is not a sin. put same field in different struct is ok, if benefits the cache
  - find in std::unordered_map, 14~24 ns. dense_hash_map is better
  - better hash table implementation
  - ((always_inline)) and ((noinline)) are a stronger hint to the compiler than standard inline keyword
  - keeping the cache line hot, 5us faster
    - run a very frequent dummy path through your entire system, keeping both your data cache and instruciton cache primed
  - std::function might allocate, https://godbolt.org/z/97c47d81G, use inplace_function instead
  - std::pow can be slow if the accuracy of the result isn't acceptable after the first phase
[E] CppCon 2017 - Chandler Carruth “Going Nowhere Faster”-2EWejmkKlxs.mp4
  - google bench
  - L2~3 cache effects
  - perf stat, "frontend cycles idels" high and '-e L1-icache-loads,L1-icache-load-misses,L1-dcache-loads,L1-dcache-load-misses'
    - 0.01% -> 0.04% L1-dcache-load-misses causes 25% performance regression
  - cmovge
  - macro code
[D] CppCon 2017 - Charles L. Wilcox “The Three Layers of Headers A Curious Discovery”-su9ittf-ozk.mp4
[D] CppCon 2017 - Dave Watson “C++ Exceptions and Stack Unwinding”-_Ivd3qzgT7U.mp4
[D] CppCon 2017 - David Sankel “Choosing an Abstraction”-KYa_LaYKw3w.mp4
[E] CppCon 2017 - David Sankel “So, you inherited a large code base...”-B2XtqVZcSdM.mp4
  - principle pitfalls for large projects
    1. assumption
    2. distraction
    3. neophilia
    4. lack of follow-through
[T] CppCon 2017 - Fedor Pikus “C++ atomics, from basic to advanced.  What do they really do”-ZQFzMfHIxng.mp4
[A] CppCon 2017 - John Lakos “Local ('Arena') Memory Allocators (part 1 of 2)”-nZNd5FjSquk.mp4
[A] CppCon 2017 - John Lakos “Local ('Arena') Memory Allocators (part 2 of 2)”-CFzuFNSpycI.mp4
[E] CppCon 2017 - Kostya Serebryany “Fuzz or lose...”-k-Cv8Q3zWNQ.mp4
  - libfuzzer
  - OSS-Fuzz
  - fuzzing a compiler with complex code
[E] CppCon 2017 - Louis Brandy “Curiously Recurring C++ Bugs at Facebook”-lkgszkPnV8g.mp4
  - std::map[] is mutable
  - volatile
  - shared_ptr is not thread safe
  - vexing parsing
  - RAII type + default constructor -> DANGER
      ```cpp
      // if possible, parsing it as declaration
      // this equals to unique_lock<mutex> m_mutex, -Wshadow will find this bug
      unique_lock<mutex>(m_mutex);
      ```
[D] CppCon 2017 - Mathieu Ropert “Using Modern CMake Patterns to Enforce a Good Modular Design”-eC9-iRN2b04.mp4
[D] CppCon 2017 - Matt Godbolt “What Has My Compiler Done for Me Lately Unbolting the Compiler's Lid”-bSkpMdDe4g4.mp4
[E] CppCon 2017 - Matt Kulukundis “Designing a Fast, Efficient, Cache-friendly Hash Table, Step by Step”-ncHmEUmJZf4.mp4
  - 1% cpu and 4% ram are used by hash tables in google
  - if everything fits in L1, only need to count instructions
  - only insert and find matter
  - implementationof std::unordered_map
[D] CppCon 2017 - Michael Price “Function default arguments - Slingshot or Shotgun”-NeJ85q1qddQ.mp4
  - don't use it, use function overloading to delegate instead
  - name lookup problems
  - std::source_location works, because default argument gets evaluated at the call site
[E] CppCon 2017 - Mikhail Matrosov “Refactor or die”-fzmjXK9JZ9o.mp4
  - to fix a bug
    1. refactor current code so that the bug is obvious and easy to fix
    2. fix the bug smoothly, with as little changes as possible
  - to implement a features
    1. refactor current architecture so that the feature now fits into it
    2. implement the feature smoothly, with as littble changes as possible
  - separate them into several commits
  - mark commits
  | kind of change | impact    | mark | affected SemVer version | reviewer attention |
  |----------------|-----------|------|-------------------------|--------------------|
  | modification   | unlimited | (*)  | major                   | high               |
  | bug fix        | unlimited | (-)  | major                   | high               |
  | new feature    | unlimited | (+)  | minor                   | moderate           |
  | refactoring    | limited   | (~)  | patch                   | low                |
  | trivial change | limited   | (=)  | patch                   | low                |
[E] CppCon 2017 - Nicolai Josuttis “C++ Templates Revised”-ULX_VTkMvf8.mp4
  - his template book content
  - traits implementations
  - history of make_pair
  - string_view is worse than string&
    - prvalue/reference semantics with lvalue
    - but no lifetime extension
  - don't use string_view to initialize a std::string
    - no std::string at the end of a std::string_view chain
    - no std::string_view as arg in constructor for std::string member
  - never return std::string
  - never initialize a rturned value as std::string_view
  - perfect forwarding return values
      ```cpp
      template <typename Callable, typename... Args>
      decltype(auto) call(Callable&& op, Args&&... args) {
        if (constexpr(std::is_same_v<std::invoke_result_t<Callable, Args...>, void>) {
          std::invoke(std::forward<Callable>(op), std::forward<Args>(args)...);
          return
        } else {
          decltype(auto) ret {std::invoke(std::forward<Callable>(op), std::forward<Args>(args)...};
          return ret;
        }
      }
      ```
  - nested pack expansions
    ```cpp
    template <typename...Types>
    class Variant : private VariantStorage<Types...>, // storage with maxsize of Types...
                    private VariantChoice<Types, Types...>... { // each base class handles its value
      template <typename T, typename... OtherTypes> friend class VariantChoice; // enable CRTP
    public:
      using VariantChoice<Types, Types...>::VariantChoice...; // inherit all constructors
      using VariantChoice<Types, Types...>::operator=...;     // inherit all assignments
      ~Variant() { destroy(); }
      void destroy() {
        (VariantChoice<Types, Types...>::destroy(), ...); // call destroy on each base class
        this->setDiscrimitor(0);
      }
    };
    /*
    Variant<int, double, std::string> produces
    class Variant : private VariantStorage<int, double, std::string>,
                    private VariantChoice<int, int, double, std::string>,
                    private VariantChoice<double, int, double, std::string>,
                    private VariantChoice<std::string, int, double, std::string>,
    */
    ```
[E] CppCon 2017 - Nicolai Josuttis “The Nightmare of Move Semantics for Trivial Classes”-PNRju6_yn3o.mp4
  - Cust
      ```cpp
      class Cust {
      private:
        std::string first;
        std::string last;
        int         id;
      public:
        template <typename S1, typename S2 = std::string>
        requires std::is_convertible_v<S1, std::string>
        Cust(S1&& f, S2&& l = "", int i = 0)
          : first(std::forward<S1>(f), last(std::forward<S2>(l)), id(i) {}
      };

      Cust c{"Joe", "Fix", 42};
      Cust f{"Nico"};
      class VIP : public Cust {
        using Cust::Cust;
      };

      VIP v = "Boss";
      VIP v2{v};
      Cust cv{v};
      ```
[E] CppCon 2017 - Nir Friedman “What C++ developers should know about globals (and the linker)”-xVT1y0xWgww.mp4
  - using `inline` to qualify global vars to avoid crash, or not in c++17
  ```cpp
  namespace detail {
  std::string& g_str() {
    static std::string s = "...";
    return s;
  }
  static auto& g_str = detail::g_str();
  ```
[A] CppCon 2017 - Pablo Halpern “Allocators - The Good Parts”-v3dz-AKOVL8.mp4
[E] CppCon 2017 - Phil Nash “The Holy Grail! A Hash Array Mapped Trie for C++”-imrSQ82dYns.mp4
  - list, tree
[D] CppCon 2017 - Scott Schurr “Type Punning in C++17 - Avoiding Pun-defined Behavior”-sCjZuvtJd-k.mp4
  - it is safe to ignore trivial type's destructor
  - std::launder
  - uintptr_t <-> pointer garanteed to be ok, if no arithmetic ops
  - uintptr_t <-> pointer, they might not have the same representation
[D] CppCon 2017 - Stephen Dewhurst “Modern C++ Interfaces...'-PFdWqa68LmA.mp4
  - to embedding our design experience directly in self-maintaining code
      ```cpp
      template <typename T>
      inline T* copy_array(T const *s, size_t n) {
        size_t const amt = sizeof(T) * n;
        T* d = static_cast<T*>(::operator new(amt));
        if constexpr (is_trivially_copable<T>::value)
          d = static_cast<T*>(memcpy(d, s, amt);
        else if constexpr (has_nothrow_copy_constructor<T>::value)
          for (size_t i = 0; i != n; ++i)
            new(&d[i]) T (s[i]);
        else {
          /* .. */
        }
      }
      ```
  - SFINAE
[D] CppCon 2017 - Walter E. Brown “Programming with C++ Constraints - Background, Utility, and Gotchas'-n4ie7tPMXOQ.mp4
  - SFINAE
  - constexpr if
  - Concept
[E] CppCon 2017 - Walter E. Brown “Whitespace ≤ Comments ＜＜ Code”-NLebZ3XT92E.mp4
[E] CppCon 2018 - Alan Talbot “Moving Faster - Everyday efficiency in modern C++”-EovBkh9wDnM.mp4
  - many programs do not spend all their time in a small bit of code
  - write (almost) everything optimally
  - avoid cache misses, allocations
  - member order
  - passing parameters
  - node extraction
  - container choice
  - emplace
  - benchmarks for containers
[D] CppCon 2018 - Alastair Rankine “Tools and Techniques for Testing Callbacks Using Standard C++”-9aGI5k8DmT8.mp4
  - mocking
[D] CppCon 2018 - Andrew Sutton “Concepts in 60 - Everything you need to know and nothing you don't”-ZeU6OPaGxwM.mp4
[E] CppCon 2018 - Brian Ruth “std - -basic_string - for more than just text”-SDJImePyftY.mp4
  - using basic_string as generic purpose container
[D] CppCon 2018 - Chandler Carruth “Spectre - Secrets, Side-Channels, Sandboxes, and Security”-_f7O3IfIR2k.mp4
[D] CppCon 2018 - Dan Saks “Making New Friends”-POa_V15je8Y.mp4
[E] CppCon 2018 - Fedor Pikus “Design for Performance”-m25p3EtBua4.mp4
  - optimize a matrix product
  - google bench
  - compute bound or memory bound
  - vectorization
[D] CppCon 2018 - Greg Falcon “Initialization, Shutdown, and constexpr”-6ZOygaUjzjQ.mp4
  - ensure safety
    - always declare the objects constexpr
    - only declare global objects with trivial destructors
    - -Wglobal-constructors will catch errors in these two cases
  - work around the problem, new(?)
      ```cpp
      // foo.h
      namespace example {
      const std::string& GlobalKey();
      }

      // foo.cc
      namespace example {
      const std::string& GlobalKey() {
        static auto* ptr = new std::string(MakeKey());
        return *ptr;
      }
      ```
[D] CppCon 2018 - JF Bastien “Signed integers are two's complement”-JhUxIVf1qok.mp4
  - __builtin_add_overflow
  - some famous overflow bug
  - how undefined signed overflow enables optimizations in GCC, 12%[0%,40%] perf different
[E] CppCon 2018 - Jason Turner “Surprises in Object Lifetime”-uQyT-5iWUow.mp4
[D] CppCon 2018 - John Woolverton “Interfaces Matter”-PG_sbSZL06U.mp4
[D] CppCon 2018 - Jon Kalb “Copy Elision”-IZbL-RGr_mk.mp4
[E] CppCon 2018 - Jonathan Boccara “105 STL Algorithms in Less Than an Hour”-2olsGf6JIkU.mp4
[D] CppCon 2018 - Jonathan Keinan “Cache Warming - Warm Up The Code”-XzRxikGgaHI.mp4
[D] CppCon 2018 - Mateusz Pusz “Git, CMake, Conan - How to ship and reuse our C++ projects”-S4QSKLXdTtA.mp4
[D] CppCon 2018 - Matt Godbolt “The Bits Between the Bits - How We Get to main()”-dOfucXtyEsU.mp4
[E] CppCon 2018 - Matthew von Arx “Set it and forget it!”-Dm0OMYUZ06A.mp4
  - jenkins, git, gitlab, docker, cmake, llvm, gcc, clang-tidy, cppcheck, boost test, kcov, llvm sanitiers, doxygen, redmine
[E] CppCon 2018 - Nir Friedman “Understanding Optimizers - Helping the Compiler Help You”-8nyq8SNUTSc.mp4
[D] CppCon 2018 - Peter Sommerlad “Woes of Scope Guards and Unique_Resource - 5+ years in the making”-O1sK__G5Nrg.mp4
[E] CppCon 2018 - Phil Nash “You're Not as Smart as You Think You Are”-fbkfH0IZW8g.mp4
  - monkey business illusion, miss the garilla and curtain color change
  - remember 5 iterms
[E] CppCon 2018 - Richard Powell “How to Argue(ment)'-ZbVCGCy3mGQ.mp4
[D] CppCon 2018 - Sean Parent “Better Code - Human Interface”-0WlJEz2wb8Y.mp4
[E] CppCon 2018 - Simon Brand “How to Write Well-Behaved Value Wrappers”-J4A2B9eexiw.mp4
  - spaceship
  - use noexcept for move and swap
  - c++20 stuff
[E] CppCon 2018 - Simon Brand “Overloading - The Bane of All Higher-Order Functions”-L_QKlAx31Pw.mp4
  ```cpp
  #define FWD(...) \
    foo(std::forward<decltype(__VA_ARGS__)>(__VA_ARGS__)...)
  #define LIFT(X) [](auto&&... args) \
    noexcept(noexcept(X(FWD(args)...))) \
        -> decltype(X(FWD(args)...)) \
      { \
        return X(FWD(args)...); \
      }

  std::transform(first, last, target, LIFT(foo));
  ```
[K] CppCon 2018 - Steven Simpson “Source Instrumentation for Monitoring C++ in Production”-0WgC5jnrRx8.mp4
  - structured log file
[E] CppCon 2018 - Timur Doumler “Can I has grammar”-tsG95Y-C14k.mp4
[E] CppCon 2018 - Timur Doumler “Class template argument deduction in C++17”-UDs90b0yjjQ.mp4
[E] CppCon 2018 - Titus Winters “Modern C++ Design (part 1 of 2)”-xTdeZ4MxbKo.mp4
  - Good overload sets
    - correctness can be judeged at the call site without knowing which overload is picked
    - a single good comment can discribe the full set
    - each element of the set is doing "the same thing"
    - most important overload set: copy + move
  - be aware of non-owning type parameters, like string_view, span, etc.
  - method qualifier overloads
      ```cpp
      std::string std::stringbuf::str() const &;
      std::string std::stringbuf::str() &&;

      // rvalue-ref qualifier can mean "steal"
      return std::move(buf).str(); // should return like this
      ```
[E] CppCon 2018 - Titus Winters “Modern C++ Design (part 2 of 2)”-tn7oVNrPM8I.mp4
[E] CppCon 2018 - Walter Brown “Communicating via Diagnostics - Observations and Tips for Authors”-GNhwzTlcDp0.mp4
  - be explicit that something has gone wrong
  - use human-readable, comprehensible language
  - avoid inconsistencies
  - above all, be helpful
[E] CppCon 2019 - Andrei Alexandrescu “Speed Is Found In The Minds of People'-FJJTYQYB1JQ.mp4
  - sorting
[E] CppCon 2019 - Arthur O'Dwyer “Back to Basics - RAII and the Rule of Zero”-7Qgd9B1KuMQ.mp4
  - the rule of three
    1. a destructor to free the resource
    2. a copy constructor to copy the resource
    3. a copy assignment operator to free the left-hand resource and copy the right-hand one, use the copy-and-swap idiom to implement assignment
        ```cpp
        NaiveVector& NaiveVector::operator=(const NaiveVector& rhs) {
          NaiveVector copy(rhs);
          copy.swap(*this);
          return *this;
        }
        NaiveVector& NaiveVector::operator=(NaiveVector&& rhs) {
          NaiveVector copy(std::move(rhs));
          copy.swap(*this);
          return *this;
        }

        // or just

        NaiveVector& NaiveVector::operator=(NaiveVector rhs) {
          copy.swap(*this);
          return *this;
        }
        ```
  - the rule of four (and a half)
    1. a by value assignment operator to free the left-hand resource and transfer ownership of the right-hand one
    2. 1/2 (a nonmember swap function, and ideally a member version too)
  - no longer naiive vector
      ```cpp
      struct Vec {
        Vec(const Vec& rhs) {
          ptr_ = new int[rhs.size_];
          size_ = rhs.size_;
          std::copy(rhs.ptr_, rhs.ptr_+size_, ptr_);
        }
        Vec(Vec&& rhs) noexcept {
          ptr_ = std::exchange(rhs.ptr_, nullptr);
          size_ = std::exchange(rhs.size_, 0);
        }
        friend void swap(Vec& a, Vec& b) noexcept { a.swap(b); }
        ~Vec() { delete [] ptr_; }
        Vec& operator=(Vec copy) { // noexcept?
          copy.swap(*this);
          return *this;
        }
        void swap(Vec& rhs) noexcept {
          using std::swap;
          swap(ptr_, rhs.ptr_);
          swap(size_, rhs.size_);
        }
        ```
  - closer-to-rule-of-zero vector
      ```cpp
      struct Vec {
        std::unique_ptr<int[]> uptr_;
        int size_;

        Vec(const Vec& rhs) {
          uptr_ = std::make_unique<int[]>(rhs.size_);
          size_ = rhs.size_;
          std::copy(rhs.uptr_.get(), rhs.uptr_().get()+size_, uptr_.get());
        }
        Vec(Vec&& rhs) noexcept = default;
        ~Vec() = default;
        Vec& operator=(Vec copy) { // noexcept?
          copy.swap(*this);
          return *this;
        }
        void swap(Vec& rhs) noexcept {
          using std::swap;
          swap(ptr_, rhs.ptr_);
          swap(size_, rhs.size_);
        }
        ```
[E] CppCon 2019 - Arthur O'Dwyer “Back to Basics - Type Erasure”-tbUCHifyT24.mp4
  - template has to be in header file, we need a concrete type
      ```cpp
      struct TE {
        void *repr_ = nullptr;
        void *(*abc)(ACTION_ENUM, void* data, void* out);
      }
      ```
  - type safe type erasure, but cannot do SSO
  - get type by comparing typeid(T)
[E] CppCon 2019 - Barath Kannan “Generalised Double Dispatch”-nNqiBasCab4.mp4
  - something like std::visit, recursive template inheritance
[E] CppCon 2019 - Ben Deane “Everyday Efficiency - In-Place Construction (Back to Basics)”-oTMSgI1XjF8.mp4
  - move is not free
  - RVO
      ```cpp
      S no_rvo(bool b) {
        S s{1};
        return b ? s : S{0}; // lvalue, wrong type, not even a move, copying
      }

      S yes_rvo(bool b) {
        return b ? get_s() : S{0};
      }
      ```
[E] CppCon 2019 - Chandler Carruth “There Are No Zero-cost Abstractions”-rHIkrotSwcc.mp4
  - single cpp file takes >15m to compile
  - unique_ptr as parameter, passing by value, not reference
[E] CppCon 2019 - Chandler Carruth, Titus Winters “What is C++”-LJh5QCV4wDg.mp4
  - "...almost no c++ programmers are *totally* shure how c++ works, and the ones which are entirely confident seem to be mostly the ones who are also demonstrably wrong about it"
[E] CppCon 2019 - Conor Hoekstra “Algorithm Intuition (part 1 of 2)”-pUEnO6SvAMo.mp4
[E] CppCon 2019 - Conor Hoekstra, “Algorithm Intuition (part 2 of 2)”-sEvYmb3eKsw.mp4
[D] CppCon 2019 - Craig Scott “Deep CMake for Library Authors”-m0DwB4OvDXk.mp4
[D] CppCon 2019 - Dan Saks “Back to Basics - Const as a Promise”-NZtr93iL3R0.mp4
[E] CppCon 2019 - Jason Turner “C++ Code Smells”-f_tLQl0wLUM.mp4
[E] CppCon 2019 - Jon Kalb “Back to Basics - Object-Oriented Programming”-32tDTD9UJCE.mp4
  1. make every class in your hierarchy either a base-only or leaf-only
  2. make bases
    1. abstract
    2. protected assignment operators
  3. make leaf classes
    1. concrete
    2. public assignment operators
    3. final
  - NVI: consider make virtual functions nonpublic, and public functions nonvirtual
[E] CppCon 2019 - Marshall Clow “std - -midpoint How Hard Could it Be”-sBtAGxBh-XI.mp4
[E] CppCon 2019 - Mathieu Ropert “Crowd Review”-_W4pX_k1AAQ.mp4
  - "cannot do worse than this guy"
[E] CppCon 2019 - Miro Knejp “Non-conforming C++ - the Secrets the Committee Is Hiding From You”-IAdLwUXRUvg.mp4
  - case ranges: `case '0' ... '9':`
  - the elvis operator: expr1 ? expr1 : expr2 -> expr1?:expr2
  - designated array initializers
      ```cpp
      enum color { red, green, blue };
      constexpr string_view color_name[] = { [green] = "green", [red] = "red", [blue] = "blue" };
      constexpr uint32_t    color_value[] = { [blue] = 0xff0000, [red] = 0x0000ff, [green] = 0x00ff00 };
      ```
  - flexible array member, DON'T USE placement array new
      ```cpp
      struct header { int size; thing some; };

      constexpr size_t x = (sizeof(header) + alignof(double) -1) / alignof(double) * alignof(double);
      byte* buffer = new byte[x + n * sizeof(double)];
      header* p = new(buffer) header{n};

      // there is a non-negative UNSPECIFED overhead in all array new-expressions
      // placement overhead may vary from one invocation of new to another
      new(buffer + x) double[n]; // overwriten header struct
      // should use
      uninitialized_default_construct_n(reinterpret_cast<double*>(buffer + x), n);

      double* data = reinterpret_cast<double*>(buffer + x);
      // can't do this
      // because p pointers to one thing, not an array
      double* data = reinterpret_cast<double*>(reinterpret_cast<byte*>(p) + x);

      // UB because data is not an array, just an pointer, so [1] and [2] don't work
      data[0] = data[1] + data[2];
      ```
      ```cpp
      struct header {
        int size;
        double data[];
        ~header() { destroy_n(data, n); }
      };

      size_t bytes = sizeof(header) + n*sizeof(double);
      byte* buffer = new byte[bytes];
      header* p = new(buffer) header{n};
      uninitialized_default_construct_n(p->data, n);

      p->data[0] = p->data[1] + p->data[2];

      p->~header();
      delete[] reinterpret_cast<byte*>(p);
      ```
  - computed goto; makes lua up to 41% faster, cpython 1x% faster
      ```cpp
      auto run(bytecode const* instructions) {
        constexpr void* labels[] = {
          [bytecode::add1] = &&add1_label,
          [bytecode::add2] = &&add2_label,
          //...
        };

        auto const next = [&] { reutrn labels[*instructions++]; };

        auto value = 0;
        goto* next();

      add1_label:
        value += 1.0;
        goto* next();
      add2_label:
        value += 2.0;
        goto* next();
      //...
      halt_label:
        return value;
      ```
[E] CppCon 2019 - Nicolai Josuttis “When C++ Style Guides Contradict”-WRQ1xqYBKgc.mp4
  - don't use .h, use .hpp for headers
  - use {} for initalization
  - hidden friend
  - virtual, override, final, exactly one(!)
      ```cpp
      class A {
        virtual std::string getId() const final; // have both virtual and final to guarantee
        // it will not be overwitten by subclasses
        // and it will be inlined by compiler as the top level function, won't be in vtable
      };
      ```
    - either all member functions or none are virtual
[D] CppCon 2019 - Peter Bindels & Sy Brand 'Hello World From Scratch'-4V9QWHjRPMc.mp4
[E] CppCon 2019 - Phil Nash “Keep Your Friends under control”-vPXZxQm-2-0.mp4
  - make friend function inline disables ADL, because technically it is not in the same namespace as the class
      ```cpp
      namespace Animals {
        class Badger {
          int size = 42;
          friend badgerSize(Badger const& badger) {
            std::cout << badger.size << '\n';
          }
        };
      }
      Animals::Badger b;
      badgerSize(b);
      Animals::badgerSize(b); // doesn't work anymore
      ```
  - remove error messages, because compiler will not look into a class if the class type is not involved
[A] CppCon 2019 - Rainer Grimm “Atomics, Locks, and Tasks (part 1 of 2)”-o0i2fc0Keo8.mp4
[A] CppCon 2019 - Rainer Grimm “Atomics, Locks, and Tasks (part 2 of 2)”-_eaB69ta_ig.mp4
[D] CppCon 2019 - Rian Quinn 'Using Freestanding C++ for C++17 in Shellcode, UEFI, Embedded & Unikernels'-bKPN-CGhEC0.mp4
[A] CppCon 2019 - Samy Al Bahra, Paul Khuong “Abusing Your Memory Model for Fun and Profit”-N07tM7xWF1U.mp4
[D] CppCon 2019 - Titus Winters “Maintainability and Refactoring Impact of Higher-Level Design Features”-v_yzLe-wnfk.mp4
  - `using` for replacing old types, like `template <typename T> using MyVector = std::vector<T>;`
[D] CppCon 2019 -Ben Saks “Back to Basics - Understanding Value Categories”-XS2JddPq7GQ.mp4
[D] CppCon2014 - Hyrum Wright 'Large-Scale Refactoring @ Google'-ZpvvmvITOrk.mp4
  - clang tools
[E] Crazy Code, Crazy Coders - Walter E. Brown - Closing Keynote Meeting C++ 2019-OAmWHmwlMwI.mp4
  - "A computer is a stupid machine with the ability to do incredibly smart things,... while computer programmers are smart people with the ability to do incredibly stupid things." -- Bill Bryson
  - "[W]hen you need to pay tuition and a mortgage, you are willing to put up with a certain amount of stupidity so that you can take care of your family. Once those bills are paid, your tolerance for idiocy shrinks quite a bit." - It's no big deal
  - learning floating point numbers
  - labmda to initialize const variables
  - using `K!=N` instead of `K<N` in for loop
  - using `auto&&` in range for loops
  - whenever possbile, sum the smallest values first, to reduce risk of loss of significance
  - no computer arithmetic is simple
  - "Debuggin is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it" -- Brian W. Kernighan & P.J. Plauger
  - "When I wrote this code, only God and I knew what's going on. Now only God knows."
[D] Daniel Penning - The hidden risks in off target testing - Meeting Embedded 2020-P5dqztrG7iA.mp4
  - different underlying types for enum on different platforms
[D] Data Orientation For The Win! - Eduardo Madrid - CppCon 2021-PQ3WLuT01y4.mp4
[D] Declarative thinking, declarative practice - Kevlin Henney - Meeting C++ 2017-1s-BGBA8Nqo.mp4
[D] Design Idioms from an Alternate Universe - Ivan Čukić - CppCon 2021-nw20sMc3LD0.mp4
  - `void set_property(type value)` to `auto with_property(object&&, type value) -> object&&`
  - use composition over inheritance
  - sum types -> std::variant, no invalid states
  - `optioinal transform(... opt, ... fun) { if (!opt) return {}; return { std::invoke(fun, *opt) }; }`
[D] Design Patterns for Handling_Reporting Errors in C++ - Parallel Algorithms & Executors -Mark Hoemmen-DpLZ4pnrx0o.mp4
[D] Don't Help the Compiler [AKtHxKJRwp4].mp4
  - const non-ref return signature prohibits moving when passing as a rvalue param
      ```cpp
      const std::string foo();
      void bar(std::string&&);
      bar(foo()); // copy
      ```
  - using std::plus<> etc. for transparent operations
[E] Dynamic Polymorphism With Code Injection and Metaclasses - Sy Brand [ ACCU 2021 ]-r14-lYalR6c.mp4
  - problems with inheritance
    1. often requires dynamic allocation
    2. ownership and nullable consideratioins
    3. intrusive: requires modifying child classes
    4. No more value semantics
    5. changes semantics for algorithms and containers, because of pointers vs types
  - clone and move on her talk
  ```cpp
  struct vtable {
    void (*speak)(void *ptr);
    void (*destroy_)(void *ptr);
  };

  template <class Concrete>
  constexpr vtable vtable_for {
    .speak    = [] (void* ptr) { static_cast<Concrete*>(ptr)->speak(); };
    .destroy_ = [] (void* ptr) { static_cast<Concrete*>(ptr)->destroy_(); };
  };

  struct animal {
    void* concrete_;
    vtable const* vtable_;

    template <typename T>
    animal(T const& t): concrete_(new T(t)), vtable_(vtable_for<T>) {}

    void speak() { vtable_->speak(t_); }
    ~animal() { vtable_->destroy_(t_); }
  };

  struct cat { void speak(); };
  struct dog { void speak(); };

  int main() {
    animal c = cat{};
    c.speak();

    animal d = dog{};
    d.speak();
  }
  ```
[E] Dynamically Loaded Libraries Outside the Standard - Zhihao Yuan - CppCon 2021--dxCaM4GOqs.mp4
  - dlopen etc.
  - dynamic linking vs dynamic loading
  - delay loading: the addresses of functions may change at runtime, address of thunk != address of the actual function
  - maybe UB
[E] Embracing (and also Destroying) Variant Types Safely - Andrei Alexandrescu - CppCon 2021-va9I2qivBOA.mp4
  - ... to the left of a name means "introduce"
  - ... to the right of a patterns "expand"
[E] Embracing User-Defined Literals Safely - Pablo Halpern - ACCU 2022 [_nW2iB6_BAU].mp4
  - still don't find this is useful
[E] Empirically Measuring, & Reducing, C++’s Accidental Complexity - Herb Sutter - CppCon 2020-6lurOCdaj0Y.mp4
  - bad named value seqence: using ehm = integer_seqence<double, 1.5, 3.14>
  - we should have a type sequence: template <typename... Ts> struct type_sequence {};
  - and more
    ```cpp
    // doesn't seem to be correct
    template <typename ...Ts> struct head;
    template <typename T, typename... Ts> struct head<type_sequence<T, Ts...>> { using type = T; };
    template <typename T> using head_t = typename head<T>::type;

    template <typename ...Ts> struct tail;
    template <typename T, typename ...Ts> struct tail<type_sequence<T, Ts...>> {
      using type = type_sequence<Ts...>;
    };
    template <typename T> using tail_t = typename tail<T>::type;

    template <typename T, typename List> struct cons;
    template <typename T, typename ...Ts> struct cons<T, type_sequence<Ts...>> {
      using type = type_sequence<T, Ts...>;
    };
    template <typename T, typename List> using cons_t = typename cons<T, List>::type;
    ```
    - greedy matching and fair matching
    ```cpp
    template <typename T, typename ...Ts, typename U> int f(T, U, const Ts&...);
    // type U can not be specified, always deduced
    // but Ts must always be explicit
    ```
  - `template <typename... Ts, typename ...Us> int f(Ts... ts, Us... us);`, `Us` is always deduced(greedy matching), `Ts` is always explicit(fair matching)
  - variant layout
    ```cpp
    template <typename ...Ts> struct variant;
    template <typaname T, typaname ...Ts> struct variant<T, Ts...> {
      enum: size_t { size = sd::max({sizeof(T), sizeof(Ts)...}) };
      alignas(T) alignas(Ts...) char d_data[size];
      unsigned d_active;
    };
    template <size_t i, typename... Ts>
    constexpr auto& get(const variant<Ts...>& v) {
      if (i != v.d_active) throw bad_variant_access("You're fired");
      using T = variant_alternative_t<i, Ts...>;
      return *static_cast<const T*>(&v.d_data);
    }
    template <unsigned N, typename T, typename... Ts>
    struct variant_alternative : variant_alternative<N-1, Ts...> {};
    template <typename T, typename ...Ts> struct variant_alternative<0, T, Ts...> { using type = T; };

    // O(n)
    template <unsigned> void destroyLinear(unsigned, void*) {}
    template <unsigned i, typename T, typename... Ts> void destroyLinear(unsigned n, void* p) {
      if (n == i) static_cast<T*>(p)->~T();
      else destroyLinear<i+1, Ts...>(n, p);
    }
    template <typename ...Ts> variant<Ts...>::~variant() {
      if (d_active < sizeof ...(Ts)) destroyLinear<0, Ts...>(d_active, &d_data);
    }

    // O(lgn)
    template <unsigned lo, unsigned hi, typename...Ts> void destroyLog(unsigned n, void* p) {
      static_assert(lo < hi);
      assert(n >= lo && n < hi);
      constexpr size_t m = lo + (hi + low)/2;
      if (n < m) {
        destroyLog<lo, lo==m?hi:m, Ts...>(n, p);
      } else if (n > m) {
        destroyLog<m+1==hi?lo:(m+1), hi, Ts...>(n, p);
      } else {
        using Tn = variant_alternative_t<m, Ts...>;
        static_cast<Tn*>(p)->~Tn();
      }
    }
    template <typename... Ts>
    variant<Ts...>::~variant() {
      if (d_active < sizeof...(Ts))
        destroyLog<0, sizeof...(Ts), Ts...>(d_active, &d_data);
    }
    //But: O(n2) template intialization

    // O(1)
    template <typename T>
    static void destroyElement(void* p) { static_cast<T*>(p)->~T(); }
    template <typename... Ts>
    void destroyCtTime(unsigned n, void* p) {
      static const auto dt[] = { &destroyElement<Ts>... };
      dt[n](p);
    }
    //But: indirect calls (gcc, clang) very slow
    //But: wastful for trivial dtors (often)

    // True solution: algorithm selection
    ```
[E] Engineering Distinguished Speaker Series - Howard Hinnant-vLinb2fgkHk.mp4
  - a special member can be
    1. not declared: not exist
        ```cpp
        struct X {
          template <typename...Args> X(Args&...args);
          // the default ctor is not declared
          // but can be default constructible by variadic ctor
          // members not-declared do not participate in overload resolution
        };
        ```
        ```cpp
        struct X {
          template <typename...Args> X(Args&...args);
          // X() binds to the defaulted default ctor instead of the variadic ctor
          X() = default;
        };
        ```
        ```cpp
        struct X {
          template <typename...Args> X(Args&...args);
          // X() fails to compile
          // becasue deleted members participate in overload resolution
          X() = delete;
        };
        ```
    2. implicit declared: compiler generate default or delete
    3. user declared: deleted, defaulted, user-defined
        ```cpp
        struct X {
          X() {}
          X();
          X() = default;
          X() = delete;
        };
        ```
  - should I define one special member in terms of another? No!
  - copy-swap idiom
      ```cpp
      struct S {
        explicit S(std::size_t size) : buf_(new char[size]), size_(size) {}
        S(S const& other) : S(other.size_) {}
        S(S&& other) noexcept { swap(*this, other); }
        S& operator=(S const& other) & {
          auto t = other;
          swap(*this, t);
          return *this;
        }
        S& operator=(S&& other) & noexcept {
          swap(*this, other);
          return *this;
        }
        ~S() { delete[] buf_; }

        friend void swap(S& s1, S& s2) noexcept {
        	using std::swap;
          swap(s1.buf_, s2.buf_);   // C.165: not using std::swap
          swap(s1.size_, s2.size_); // to using possible ADL
        }

      private:
        char* buf_ = nullptr;
        std::size_t size_ = 0U;
      };

      // however, this ideom creates extra copies during copy assgining
      // copy assignment operator should only support basic exceptioin safety

      struct S {
        S& operator=(S const& other) & {
          if (this != &other) {
            if (size_ < other.size_) {
              size_ = 0U;
              delete[] buf_;
              buf_ = new char[other.size_];
              size_ = other.size_;
            }
            std::copy(other.buf_, other.buf_ + other.size_, buf_);
          }
          return *this;
        }
      }

      // and call strong_assignment(x, y) for strong exception gurantee
      template <typename T>
      T& strong_assign(T& dest, T src) {
        std::swap(dest, src);
        return dest;
      }
      ```
  - In A Hurry?
      ```cpp
      class X {
      public:
        X(X const&0) = delete;
        X& operator=(X const&) = delete;
      };
      ```
  - never delete the move members. OUTDATED?
[D] Episode #62 (with Sean Parent) 'I’m Surprised You Brought up Rotate'-czHpJE3xIXc.mp4
[D] Equal Rights for Tests - Jon Jagger - ACCU 2022 [9lXFuf5IN7Q].mp4
[E] Even More Modern C++-ZQWg1koOKy8.mp4
  - sort performance improvements from C to c++20
[K] Faster, Easier, Simpler Vectors - David Stone - CppCon 2021-MfFzr9qqPDw.mp4
  - using c array instead of initializer_list
  - begin + size is faster than begin + end pair, but all stl implementations are using the later one for ABI reasons
  - static_vector vs allocator, allocator size/performance overhead, and cannot be trivial
[D] Fun With Type Erasure - Pavel Novikov - ACCU 2022 [e3GcXIHL8NA].mp4
[D] Kevlin Henney - Functional C++ [CIg6eyJv4dk].mp4
[A] Frictionless Allocators - Alisdair Meredith [ ACCU 2021 ]-CQj1WLOUaqw.mp4
[D] Future of Testing With C++20 - Kris Jusiak [ ACCU 2021 ]-KlU0cb_tbuw.mp4
[D] Generic Programming Without (Writing Your Own) Templates - Tina Ulbrich [ ACCU 2021 ]-KRUnZa9OBAM.mp4
[D] Goals for Better Code - Implement Complete Types-mYrbivnruYw.mp4
[E] GoingNative 2013 C++ Seasoning-W2tWOdzgXHA.mp4
  - No Raw Loops
  - that's a rotate
      ```cpp
      template <typename I>
      auto slide(I f, I l, I p) -> pair<I, I> {
        if (p < f) return { p, rotate(p, f, l) };
        if (l < p) return { rotate(f, l, p), p };
        return { f, l };
      }

      template <typename I, typanem S>
      auto gather(I f, I l, I p, S s) -> pair<I, I> {
        return {stable_partition(f, p, not1(s)),
                stable_partition(p, l, s)};
      }
      ```
[D] HandmadeCon 2015 - Mike Acton-qWJpI2adCcs.mp4
  - docs are always missing, or don't understand
  - don't be too generic, don't introduce extra things to solve problems don't exist
[E] Herb Sutter - Bridge to new thingia - Meeting C++ online-nhzyLY171XI.mp4
  - If you don't build a strong backward compatibility bridge, expect to slow your adoption down by ~10 years
  1. Value - to address known OldThing pain (and know OldThing's value).
  2. Availability - wherever OldThing is used.
  3. Compatiblility bridge. Seamless backward interop with OldThing.
    - Good: "I can use NewThing side by side in an OldThing project."
    - Grail: "I can write 1 line of NewThing inside OldThing and see benefit."
[E] Higher Order Functions for ordinary developers - Björn Fahller - Meeting C++ 2018-qL6zUn7iiLg.mp4
  - use auto return type to return lambdas
      ```cpp
      auto equals(int num) {
        return [num] (int x) { return x == num; };
      }
      ```
  - compose
      ```cpp
      template <typename F1, typename F2> auto compose(F1 f1, F2 f2) {
        return [=](auto const& x) { return f1(f2(x)); };
      }
      ```
  - when_all
      ```cpp
      template <typename...Predicates> auto when_all(Predicates ... ps) {
        return [=](auto const& x) { return (ps(x) && ...); };
      }
      ```
  - if_then
      ```cpp
      template <typename Predicate, typename Action>
      auto if_then(Predicate predicate, Action action) {
        return [=](auto&& x) {
          if (predicate(x)) {
            action(std::forward<decltype(x)>(x));
          }
        };
      }
      ```
[E] How C++ Debuggers work - Simon Brand - Meeting C++ 2017-Q3Rm95Mk03c.mp4
[K] How It's Done - Sorting Algorithms – Karol Przybylski – code - -dive 2021-7T7Yx99lbN4.mp4
  - qsort and related ones, why std::sort is better
[D] How Profile-Guided Optimization Makes Your Code Faster Without Any Code Changes - Stephan Dollberg-3RtMMHkVsDg.mp4
[E] Hypercritical C++ Code Review - Yuri Minaev [ C++ on Sea ]-f1_Iwh33f9I.mp4
  - be aware of char type pointers, type aliasing slows everything down. vector<int> is faster than vector<uint8_t>. range base loop solves this
  - memset to zero out local memory may not work
  - proper way to do comparison, or just use <=> instead
      ```cpp
      bool operator<(Foo lhs, Foo rhs) {
        if (lhs.a < rhs.a) return true;
        if (rhs.a < rhs.a) return false;
        return lhs.b < rhs.b;
      }
      ```
[K] Implementing static_vector - How Hard Could it Be - David Stone - CppCon 2021-I8QJLGI0GOE.mp4
  - hard to impossible
  - template to get narrowest size type on compile time
  - allocator is reference type, mixing it with value types like static_vector complicates things
  - std::array alike, always construct and destruct all none trivial items
  - std::array<byte> has alignment issue
  - unintialized_array<byte> has to use reinterpret_cast, which is not allowed in constexpr context
  - using SFINAE to use both kinds of storage to allow constexpr for some types
  - std::destroy_at, std::construct_at(constexpr friendly, unlike placement new), std::addressof
[E] Ivica Bogosavljevic - The price of dynamic memory in C_C++-E01wFA1-0YM.mp4
  - memory fragmentation
    - as a result, malloc and free take more and more time and your program is less and less responsive
    - a serious problem for the long-running programs and systems - it causes allocation failures and slowdowns
    - solutions,
      1. occasioinally restart your programs
      2. preallocate all the needed memory at the program beginning
      3. cache memory chunks
      4. use special memory allocators that promise low fragmentation
  - many many examples and statistics
[E] Jakub Beránek - Going down the CPU microarchitecture rabbit hole-OM0AKazCNM4.mp4
  - kobzol/hardware-effects
  - branch prediction, processing **float** sorted array is fater than a unsorted one
    - branch-misses: 24% vs 0.4%
    - more predicatable data
    - compiler hints, `__builtin_expected(cond(), 1)`, automated with PGO
    - remove branches
  - indirect jumps: function pointers, function return address, virtual methods
    - for virtual methods,
      - increate object size, more data cache misses
      - extra indirection
      - prevents inlining
      - branch target mispredictions
    - sorted array by type can be faster slightly
  - false sharing
  - denormal FP numbers
    - -fast-match
    - CPU flags
      1. Flush-to-zero     treat denormal outputs as 0
      2. Denormals-as-zero treat denormal inputs  as 0
[E] Jason Turner - Great C++ is_trivial-vrKuSSiqk9E.mp4
  - return a const value doesn't prohibit NRVO
  - must use std::move on returning a destructure value
  - don't return const non-ref value
  - using user defined `throw_logic_err()` to throw exception instead of explicitly calling `throw` may help optimization, because of smaller function size, which helps inlining
[D] KEYNOTE - What Everyone Should Know About How Amazing Compilers Are - Matt Godbolt [C++ on Sea 2019]-w0sz5WbS5AM.mp4
[D] Klaus Iglberger - Breaking Dependencies - Type Erasure - A Design Analysis-7GIz9SmRgyc.mp4
[D] Kris Jusiak - Online AVR_Arduino Developement with C++20 - Meeting Embedded 2020-MskKTIdW45c.mp4
  - sml lib
[D] Lambdas - uses and abuses - Dawid Zalweski - Meeting C++ 2020-Onv9w6FGwIQ.mp4
  - recursive lambda -> y-combinator
[E] Lightning Talk - C++ is like Javascript - Patricia Aas [C++ on Sea 2019]-L5C4OmD79ac.mp4
[E] Lightning Talk - So You Thought C++ Was Weird Meet Enums - Roth Michaels - CppCon 2021-SGfk5l85cko.mp4
  - enums are just named numbers
  - static_cast<E>(3) is valid for `enum E {A=0, B=1, C=2};`, as long as the underlying type can hold
[D] Linux User_Kernel ABI - the realities of how C and C++ programs really talk to the OS - Greg Law-4CdmGxc5BpU.mp4
  - syscalls, /proc and posix APIs
[E] Live Compiler Development with Cross-Platform Tooling - Sy Brand [ C++ on Sea 2020 ]-Jw2n5QSul34.mp4
  - BrainFuck
    - < : left
    - > : right
    - + : increase
    - - : decrease
    - , : read from stdin, write to *cell
    - . : read from *cell, write to stdout
    - []: loop while *cell > 0
[E] Making the Most Out of Your Compiler - Danila Kutenin - CppCon 2021-lvFh1vLEcIw.mp4
  - LTO to increase visibility, 0~10% performance, at Google 4%
  - LTO can be 0.?% faster than ThinLTO, but ThinLTO is good for large code base, like millions of lines of code
  - -Ofast = -O3 + -ffast-math + some weird more(dangerous!)
  - llvm -mpopcnt enabled only in -O3
  - use `-O0 -g` for debugging purposes, use -O3 for optimization purposes
  - If -O0 is too slow, then using `-O1 -f no-omit-frame-pointer -fno-optimize-sibling-calls` instead
  - -Og works nicely only in gcc
  - bisect optimization passes
  - use != instead of < in loop, maybe
  - -m related flags on different architectures
  - generally inlining increases performance (see ThinLTO)
  - `-mbranches-within-32B-boundaries -falign-functions=32` stablize benchmarks
  - unstable ABI flags by -D_LIBCPP_ABI_UNSTABLE
    - -D_LIBCPP_ABI_ENABLE_UNIQUE_PTR_TRIVIAL_ABI solves the unique_ptr passing as parameter problem that Chandler mentioned, and 2~2.5% build size win at Google if build everything from source
  - c++20 char8_t is non-aliasing type, doesn't allow overlapping with other data, while char* can. it gives huge performance gain
  - clang is better than gcc in almost all benchmarks
  - cases
    - firefox 5~7% win: move from gcc/msvc to clang; -flto; PGO; -fexperimental-new-pass-manager(default in clang-13)
    - stockfish 3% win: -flto; -fexperimental-new-pass-manager(default in clang-13); AVX512
    - Yandex 7% win: -msse4.2; -flto=thin; AVX/FMA dynamic dispatch on hot paths; libc++; gcc -> llvm; inline threshold 1000
    - one trading company 4% win: gcc -> llvm; -flto=thin; -march=haswell; inline threshold 1000
    - ClickHouse 7~10% win, 10% smaller bin size: gcc -> llvm; -O3; -msse4.2; -flto=thin; libstdc++ -> libc++; libc++ unstable ABI; char8_t; function alignment 32; inline threshold 1000
  - google's perspective 3~5 fleet wide savings, 2-2.5% binary size win
    - run all infra built with clang/llvm
    - build and compile llvm from head
    - ThinLTO for release builds, for testing no LTO
    - PGO for highly important binaries
    - -msse4.2, -march=haswell
    - libstdc++ -> libc++
[E] Matt Godbolt (2018-06-27) - Memory and Caches-vDns3Um39l0.mp4
  - based on "What Every Programmer Should Know About Memory" by Ulrich Drepper
  - everything about memory, from transiter to cache
    - cache prefech won't cross page boundaries
    - cache associative
    - virtual memory
    - huge pages give better performance, 15 cycles improvements
    - NUMA
    - make good use of cache
      - keep data small
      - prefer linear scans
      - avoid chasing pointers
    - allocate carefully
      - allocate from right NUMA node
      - use huge pages for giant slabs
[D] Meeting C++ online - Andreas Reischuck - Using C++20 coroutines for asynchronous parsers-u41EhjrqdGc.mp4
[D] Memory-Mapped Devices as Objects - Dan Saks - CppCon 2020-uwzuAGtAEFk.mp4
  - if doing embeded
[D] Meta Polymorphism - Jonathan Boccara - Meeting C++ 2020 Opening Keynote-mU_n_ohIHQk.mp4
  - multi dispatch using templates
  - `std::map<std::pair<const std::type_info*, const std::type_info*>, void(*)(GameObject&, GameObject&)> collisioinfunctions_`
  - std::any for better value semantics
      ```cpp
      class Shape {
      public:
        template <typename ConcreteShape>
        Shape(ConcreteShape&& shape)
            : storage{std::forward<ConcreteShape>(shape)},
            , getter{[](std::any&storage) -> IShape& { return std::any_cast<ConcreteShape&>(storage); }}
        {}
        IShape *operator->() { return &getter(storage); }
      private:
        std::any storage;
        IShape& (*getter)(std::any&);
      };

      std::vectro<Shape> shapes;

      shapes.push_back(Square{});
      shapes.push_back(LightingBolt{});

      Shape createShape() { return Square{}; }

      auto shape = createShape();
      shape->draw();

      // value semantics
      auto otherShape = shape;

      // not nullable

      // change Shape to Implementation to make it generic
      template<typename Interface>
      class Implementation {};

      using Shape = Implementation<IShape>;
      ```
[D] Mocking Framworks considered, harmful! - Peter Sommerlad [ACCU2018]-SmevUyVendA.mp4
[E] Modern C and What We Can Learn From It - Luca Sas [ ACCU 2021 ]-QpAhX-gsHMs.mp4
[D] Modern C++ Safety and Security At 20 - Matthew Butler - CppCon 2020-uccarZGpDhk.mp4
[D] Modern C++ Workshop - Design Patterns with modern C++ (Part 1)-6Akl4Qgoy_Q.mp4
  - singleton is worse than global variable
[D] Modern C++ Workshop - Design Patterns with modern C++ (Part 2)-RQyWsMspUEs.mp4
  - First Rule: DO NOT USE THREADS and other low-level faciities! You'll get it wrong!
[E] Modern Linux C++ Debugging Tools - Under the Covers - Greg Law & Dewang Li [ ACCU 2021 ]-qYbGDDIsH4M.mp4
[D] More Modern CMake - Deniz Bahadir - Meeting C++ 2018-y7ndUhdQuU8.mp4
[D] Multi Threading Model in Paradox Games - Past, Present and Future - Mathieu Ropert - CppCon 2021-e_2z7uWouuk.mp4
[T] Multithreading 101 - Concurrency Primitives From Scratch -  Arvid Gerstmann - Meeting C++ 2019-9TVvpgHJElU.mp4
[D] Nicolai Josuttis - Let's Move - Meeting C++ 2020-sACa3Ax7YB4.mp4
    ```cpp
    std::string        getValue()      && { return value; } // should it be std::move(value) ?
    const std::string& getValue() const&  { return value; }
    ```
[T] No Touchy! A Case Study of Software Architecture with Immutable Objects -  CppCon 2020-ZSrIZW2Hzhk.mp4
[D] Nothing is better than copy or move - Roger Orr [ACCU 2018]--dc5vqt2tgA.mp4
[D] Oh No! More Modern CMake - Deniz Bahadir - Meeting C++ 2019-y9kSr5enrSk.mp4
[D] On 'simple' Optimizations - Chandler Carruth - Secret Lightning Talks - Meeting C++ 2016-s4wnuiCwTGU.mp4
  - vector::reserve is important
[E] Optimising a small real-world C++ application - Hubert Matthews [ACCU 2019]-fDlE93hs_-U.mp4
  1. Find unecessary calls and operations
  2. Find malloc or memcpy dominates
  3. Try different algorithms or caching result
  4. Memory bandwidth issues
  ```bash
  g++ -O3 -march=native -g a.cpp

  # default memory leak checker
  valgrind ./a.out

  # cache and branch-prediction profiler
  valgrind --tool=cachegrind --branch-sim=yes --cache-sim=yes --cachegrind-out-file=chg.out ./a.out

  # annotate souce file with cache and branch information
  cg_annotate chg.out $PWD/a.out # and auto=yes with libs info

  # call graph simulator and branch prediction emulator
  valgrind --tool=callgrind --branch-sim=yes --cacheuse=yes --callgrind-out-file=clg.out ./a.out

  # annotate source file with cache and branch information
  callgrind_annotate clg.out a.out | grep -v /usr/bin/callgrind_annotate

  # get how many system calls and how long they took
  strace -c ./a.out

  perf stat ./a.out
  # 2.04 insn per cycle # low, haswell can do about 6 # most app is 0.7
  # 0.14 stalled cycles per insn # waiting 0.14 cycles for memory
  ```
  - boost::mapped_file
[E] Pacific++ 2017 - Jason Turner 'Rethinking Exceptions'-OkgvqjJzH_Y.mp4
  - why not exceptions?
    - can bloat binary size, which affects cache utilization
    - handling exceptions can be much slower(~60x) than not
    - exceptions are even slower when executing inside a debugger that reports on them
    - the compiler cannot elide or optimize out exceptions
  - why exceptions?
    - thread safe with no additional work
    - carry context and additional information
    - work perfectly with RVO/NRVO copy and move elision
    - normal, no-exception cases have fewer conditionals and more straightforward logic
    - fewer conditionals are more optimizable and more readable
    - impossible to ignore
  - throwing in a noexcept context calls std::terminate, which is implementation defined whether to unwind
  - search linearly on array may be slower than set, even on small data set
  - lambda with a name should consider using noexcept
  - perf gain from noexcept is almost none
  - noexcept make thinking what code is doing
[D] Pacific++ 2018 - Sean Parent 'Generic Programming'-iwJpxWHuZQY.mp4
[D] Phil Nash - Exceptional low-latency C++-EP74mSiwHXk.mp4
  - exception can be 100 times slower than returning value
[D] Phil Nash - Oo Considered Harmful - Meeting C++ 2020--PAXVTyhB8s.mp4
  - OO history
[D] Pipes - How Plumbing Can Make Your C++ Code More Expressive - Jonathan Boccara - CppCon 2020-oYEpf5A2qrE.mp4
[T] Plain Threads are the GOTO of todays computing - Hartmut Kaiser - Keynote Meeting C++ 2014-4OCUEgSNIAY.mp4
[E] Plenary - Performance Matters - Emery Berger - CppCon 2020-koTf7u0v41o.mp4
  - layout biases measurement -- Mytkowicz et al. (ASPLOS'09), 40% difference
    - link order -change function addresses
    - environment variable size - moves the program stack
  - use randomization to eliminate the effect of layout which enables sound performance evaluation
  - statistics: p-value, variance, a-nova
  - virtual speedup to find performance graph
  - measure thoughput
  - latency: Little's law = latency = transactions / throughput
  - coz-profiler
[A] Practical Memory Pool Based Allocators For Modern C++ - Misha Shalem - CppCon 2020-l14Zkx5OXr4.mp4
[E] Processing Decimal Values - Dietmar Kühl [ ACCU 2021 ]-lHZRDjzDb1M.mp4
  - floating number problem
  - how to eliminate errors, multiplication instead of division, bdldfp::Decimal64
  - serialization
[D] Programming Conversations Lecture 5 part 1-IzNtM038JuI.mp4
  - following story from Going Native, google shut his down because nobody knows what rotate does
  - no raw for loops
  - projection is google in algo
[D] Programming Conversations Lecture 5 part 2-vxv74Mjt9_0.mp4
  - no raw synchronization primitives, because you most likely get it wrong
[D] Programming with GUTs by Kevlin Henney-azoucC_fwzw.mp4
[D] Rethinking the Way We Do Templates in C++ - Mateusz Pusz [ ACCU 2021 ]-IN3FgJCeXdc.mp4
  - using `struct S : template1, template2 {};` to avoid long error type messages
[A] Richard Kaiser - C++17 Polymorphic Memory Resources and STL Containers for Embedded Applications-Ju41sGwE88w.mp4
[E] Safe and Sane C++ Types - Peter Sommerlad [ACCU 2019]-93RT8TgTshA.mp4
  - Peter's Strong Type
[E] Scott Meyers - The evolving search for effective C++ - Keynote @ Meeting C++ 2014-smqT9Io_bKo.mp4
  - Effective Modern C++
  - Effective Effective Books
    1. keep item short
    2. put item titles in the imperative
    3. make item advise as specific as possible
    4. word item titles carefully
    5. prefer guidelines that say what to do oer what not to do
    6 tell the truth and nothing but the truth, but no necessarily the whole truth
    7. back items wiht solid technical arguments
    8. end each item with a summary of its advice
    9. know how to modulate the stridency of item titles
    10. cross reference liberally
    11. minimize use of footnotes
    12. be consistent when referring to yourself and your readers
    13. seek out ruthless pre-publication reviewers
  - emplacement vs insertion
    - emplace_back/emplace_front may beat push_back/push_front
    - but no reason to expect `emplace` to normally beat `insert`, because it is assignment not construction
    - emplacement should be used, when multiple arguments passed, type can be convert to type T
    - emplacement for map/sets requires extra allocation
[D] Scott Meyers – The Most Important Design Guideline-5tg1ONG18H8.mp4
  - "make interfaces easy to use correctly and hard to use incorrectly"
  - the principle of least astonishment
[E] Sean Parent - Polymorphic Task - Secret Lightning Talks @ Meeting C++ 2017-2KGkcGtGVM4.mp4
  - something is still wrong, it prints nothing
  - in youtube commend, he mentioned this is UB, https://stlab.cc/tip/2017/12/23/small-object-optimizations.html
    ```cpp
    // https://godbolt.org/z/7z4nYevM4
    #include <memory>
    #include <type_traits>
    #include <functional>

    #include <fmt/core.h>

    template <typename> class task;

    template <typename R, typename ...Args>
    class task<R(Args...)> {
        struct concept {
            void (*_dtor)(void*) noexcept;
            void (*_move)(void*, void*) noexcept;
            R (*_invoke)(void*, Args&&...);
        };

        static constexpr concept empty{._dtor = [](void*) noexcept {}, ._move = nullptr, ._invoke = nullptr};
        const concept* _concept = &empty;

        template <typename F, bool Small> struct model;
        template <typename F> struct model<F, true> {
            model(F&& f) : _f(std::forward<F>(f)) {}

            static void _dtor(void* self) noexcept { static_cast<model*>(self)->~model(); }
            static void _move(void* self, void* p) noexcept { new (p) model(std::move(*static_cast<model*>(self))); }
            static R _invoke(void* self, Args&&... args) {
                return std::invoke(static_cast<model*>(self)->_f, std::forward<Args>(args)...);
            }
            static constexpr concept vtable{._dtor = _dtor, ._move = _move, ._invoke = _invoke};

            F _f;
        };
        template <typename F>
        struct model<F, false> final {
            template <typename G>
            model(G&& f) : _p(std::make_unique<F>(std::forward<F>(f))) {}

            static void _dtor(void* self) noexcept { static_cast<model*>(self)->~model(); }
            static void _move(void* self, void* p) noexcept {
                new (p) model(std::move(*static_cast<model*>(self)));
            }
            static R _invoke(void* self, Args&&... args) {
                return std::invoke(*static_cast<model*>(self)->_p, std::forward<Args>(args)...);
            }
            static constexpr concept vtable{._dtor = _dtor, ._move = _move, ._invoke = _invoke};

            std::unique_ptr<F> _p;
        };

        static constexpr std::size_t small_size = sizeof(void*) * 4;

        std::aligned_storage_t<small_size> _model;
    public:
        template <typename F>
        task(F&& f) {
            constexpr bool is_small = sizeof(model<std::decay_t<F>, true>) <= small_size;
            new (&_model) model<std::decay_t<F>, is_small>(std::forward<F>(f));
            _concept = &model<std::decay_t<F>, is_small>::vtable;
        }
        ~task() { _concept->_dtor(&_model); }

        task(task&& x) noexcept : _concept(x._concept) { _concept->_move(&x._model, &_model); }
        task& operator=(task&& x) noexcept {
            if (this == &x) return *this;
            _concept->_dtor(&_model);
            _concept = x._concept;
            _concept->_move(&x._model, &_model);
            return *this;
        }

        R operator()(Args... args) {
            return _concept->_invoke(&_model, std::forward<Args>(args)...);
        }
    };

    int main() {
        task<std::unique_ptr<int>()> f = [_p = std::make_unique<int>(42)]() mutable {
            return std::move(_p);
        };
        fmt::print("{}", *f());
    }
    ```
[D] Sean Parent _ Keynote talk at C++ Russia, 2015-dr9sxBNrEGc.mp4
  - there is a "same" talk
  - no raw synchronization primitives
  - how he got a job in apple, by not being afraid to approach other seniors
[E] Slow Coding - Ben Deane; A View to a Thing - Jason Turner - 2020-10-11-lDZmXpsKtVA.mp4
  - slow coding
  - function_view is hard, because void* and function pointers are not castable
[D] So You Think You Know How to Work With Concepts - Andrzej Krzemieński - [CppNow 2021]-IUPaAcIk1Us.mp4
[D] SonarSource - The Power of Clean Code - Geoffray Adde & Olivier Gaudin - ACCU 2022 [IZcKDkW0I94].mp4
  - memset_s can be used to overwrite sensitive data
[K] std variant and the power of pattern matching - Nikolai Wuttke - Meeting C++ 2018-CELWr9roNno.mp4
  - space game, state transit
  - event handling
  - performance panelty
[D] Strong Types in C++ - Barney Dellar [C++ on Sea 2019]-fWcnp7Bulc8.mp4
  - see Jonathan Boccara's talk, that's the origin of this one
  - using Kilogram = StrongType<double, struct KilogramPhantomTag, Addable, Subtractable>
  - a chrono like physics lib with CRTP
  - literals
[E] Strong types for strong interfaces - Jonathan Boccara - Meeting C++ 2017-WVleZqzTw2k.mp4
  - strong lambdas/generic types and much more
  - https://github.com/JoBoccara/NamedType
[E] Structure and Interpretation of Test Cases - Kevlin Henney [ C++ on Sea 2020 ]-RX6WvaxmIyY.mp4
[A] Taming Dynamic Memory - An Introduction to Custom Allocators - Andreas Weis [ACCU 2019]-IGtKstxNe14.mp4
[D] Template Metaprogramming - Type Traits (part 1 of 2) - Jody Hagins - CppCon 2020-tiAVWcjIF6o.mp4
  - "For any given type T, the result of applying one of these templates to T and to cv T shall yield the same result."
[D] Template Metaprogramming - Type Traits (part 2 of 2) - Jody Hagins - CppCon 2020-dLZcocFOb5Q.mp4
  - "For any given type T, exactly one of the primary type categories shall yield true_type"
[E] Test Driven C++ - Phil Nash - CppCon 2020-N2gTxeIHMP0.mp4
[E] The C++ Type System Is Your Friend - Hubert Matthews [ACCU 2017]-MCiVdu7gScs.mp4
  - another way to do this
  - compile-type check because constexpr is not allow exception throwing
  - std::rel_ops is wonderful
      ```cpp
      // by defining == and <
      bool operator==(Year y1, Year y2) { return int(y1) == int(y2); }
      bool operator<(Year y1, Year y2) { return int(y1) < int(y2); }

      // then include std::rel_ops
      #include <utility>
      using namespace std::ops;

      // we get <=, >=, > and !=
      ```
  - CRTP for ops
  - policy on overflow, etc.
[D] The C++ rvalue Lifetime Disaster - Arno Schoedl [ ACCU 2021 ]-Ubr5wIm4g7c.mp4
[D] The Complete Guide to `return x;` - Arthur O'Dwyer - [CppNow 2021]-OGKAJD7bmr8.mp4
  - whole history and lots of examples
[A] The Concepts of concepts - Sandor Dargo - [CppNow 2021]-weJD_ZCr6S8.mp4
  - more nice tricks, starts from 30mins
[D] The Forgotten Art of Structured Programming - Kevlin Henney [C++ on Sea 2019]-SFv8Wm2HdNM.mp4
[D] The Hidden Secrets of Move Semantics - Nicolai Josuttis - CppCon 2020-TFMKjL38xAI.mp4
  - returning const value breaks move semantic
  - for universal reference, T cannot be template parameter
      ```cpp
      template <typanem T> struct C {
        void foo(T&&); // this is not universal reference
      };
      ```
  - full specialization can be universal reference
      ```cpp
      template <typename T> struct C {
        template <typename U> void foo(U&&);
        template <> void foo(std::string&&); // universal reference
      };
      ```
[E] The Hitchhiker's Guide to Faster Builds - Viktor Kirilov [C++ on Sea 2019]-anbOy47fBYI.mp4
  - many tools to check
  - use debug build
  - specific includes is better than `#include "everything.h"`
      ```
      find_program(iwyu_path NAMES incude-what-you-use iwyu)
      set_property(TARGET hello PROPERTY CXX_INCLUDE_WHAT_YOU_USE ${iwyu_path})
      ```
  - move function definions out of headers
    - use LTO for inlining(or unity build)
  - fwd decl used by value in signature is ok
      ```cpp
      struct foo;
      foo f(foo); // OK
      ```
  - dedicated headers with forward declarations, like `<iosfwd>` for I/O streams
  - PIMPL, helps with preserving ABI as well
  - PCH
    - gcc/clang: "-x c++-header"
  - unity builds
    - only way to catch ORD violations
    - may have clashes of symbols in anonymous namespaces
    - may have overload ambiguities
    - may have miscompilatoin, good tests can help
  - template argument independent code
      ```cpp
      // from
      template <typename T> class my_vector {
        int m_size;
      public:
        int size() const { return m_size; }
      };

      // to
      class my_class_base {
      protected:
        int m_size;
      public:
        int size() const { return m_size; }
      };

      template <typename T>
      clas my_vector: my_class_base {
      };
      ```
  - c++11 extern template. https://arne-mertz.de/2019/02/extern-template-reduce-compile-times/
      ```cpp
      /* interface.h */
      #include <vector>
      template <typename T> T identity(T in) { return in; }

      /* somewhere.cpp */
      #include "interface.h"

      // do not instantiate these templates here
      extern template int identity<int>(int);
      extern template float identity<float>(float);

      extern template class vector<int>;

      // will not instantiate
      auto g_int = identity(5);
      auto g_float = identity(15.f);
      std::vector<int> a;

      // will instantiate for bool
      auto g_unsigned = identity(true);

      /* somewhere_else.cpp */

      // instantiation for float
      template float identity<float>(float);
      // instantiation for std::vector<int>
      template class std::vector<int>;

      // instantiation for identity<int>()
      auto g_int_2 = identity(1);
      ```
  - move template functions out of headers
      ```cpp
      /* interface.h */

      // declarations
      template <typename T> T identity(T in);
      template <typename T> struct answer {
        T calculate();
      };

      /* interface.cpp */

      // definitions
      template <typename T> T identity(T in) { return in; }
      template <typename T> T answer<T>::calculate() { return T(42); }

      // explicit instantiations for int/float
      template int identity<int>(int);
      tempalte float identity<float>(float);

      // explicit instantiation for int
      template struct answer<int>;

      /* user.cpp */

      auto g_int = identity(666);
      auto g_float = identity(0.541f);

      auto g_answer = answer<int>().calculate();
      ```
  - reduce binary size
  - PGO
[D] The Point Challenge - Returning Different Types for the Same Operation - Amir Kirsh - [ ACCU 2021 ]-wNGEtlBSCLY.mp4
  - point + point doesn't make sense
  - (point + point) /2 does, what type should (point + point) be
  - std::ratio<>
  - check comment about *affine space*, seems to be great
[D] The Science of Unit Tests - Dave Steffen - CppCon 2020-FjwayiHNI1w.mp4
[E] The Speed Game - Automated Trading Systems in C++ - Carl Cook - Meeting C++ 2016-ulOLGX3HNCI.mp4
  - sw: 1- 10us, hw: 100- 1000ns
  - characteristics of automated trading systems
    - only a few lines of code in the entrie system are important
    - these lines are not exercised often
    - lots of market data envents, millions of events per seconds
    - jitter is a killy
    - very little threading/instruction vectorisation/etc
    - no mistakes, one second is 4 billion instructions
  - role of c++ in trading systems
    1. network
    2. server hardware
    3. kernel tuning
    4. c++
    5. algos, not secret or complicated, in every trading textbook
  - c++ better inlining: qsort vs sort, 200us vs 72us, SD 7us vs 1.5us
  - faster, typesafe and simple logging
    - no parsing, just write to memory in hotpath
        ```cpp
        #define LOG(formatString, ...) \
          static_assert(CountPlaceholders(formatString) == sizeof_args(__VA_ARGS__), "Number of arguments mismatch"); \
          WriteLog(formatString, ##__VA_ARGS__);
        
        constexpr size_t CountPlaceholders(const char* formatString) {
          size_t result{0};
          while (formatString[0] != '\0') {
            result += (formatString[0] == '%') ? 1U : 0U;
            formatString++;
          }
          return result;
        }
        
        template <typename... Types>
        constexpr unsigned sizeof_args(Types&&...) {
          return sizeof...(Types);
        }

        template <typename... Args>
        static void WriteLog(const char* formatString, const Args&... args) {
          // calculate space needed in buffer, then get the buffer, then store the format string, and pointer to static
          // object that knows how to format these arguments
          char* argsBuffer = /* minor details */

          // copy args in the buffer
          CopyArgs(argsBuffer, args...);
        }

        // write a single arg to the buffer and continue with the tail
        template <typename Args, typename ...Args>
        static char* CopyArgs(char* argsData, const Arg& arg, const Args&... args) {
          argsData = CopyArg(argsData, arg);
          return CopyArgs(argsData, args...);
        }

        // base case (terminator)
        inline char* CopyArgs(char* argsData) { return argsData; }

        // specialisatioin of CopyArg for trivially copyable types
        template <typename T>
        static char* CopyArg(char* argsData, T arg) {
          static_assert(std::is_trivially_copable<T>::value, "trivially-copyable types only");
          *reinterpret_cast<T*>(argsData) = arg;
          return argsData + sizeof(arg);
        }

        // https://github.com/maciekgajewski/Fast-Log
        // https://github.com/calcook/variadicLogging
        ```
  - unthrown exceptons don't appear to have a measurable cost
  - for the non-exceptional flow, it's just evaluating a conditional jump
  - keep slow path code away from the hot path
      ```cpp
      if (ok) {
        // hot path
      } else {
        // lots of lines error handling code
      }

      // all those code from cold path should be exacted
      if (ok) {
        // hot path
      } else {
        HandleError();
      }

      // and considering make HandleError() `__attribute__((noinline))`
      ```
[D] The Worst Best Practices - Jason Turner - [CppNow 2021] [KeI03tv9EKE].mp4
  - his own journey about c++
[E] The Worst Programming Language Ever - Mark Rendle - NDC Oslo 2021-vcFBwt1nu2U.mp4
[A] The hidden rules of world-class C++ code - Boris Schäling - Meeting C++ 2017-fu6N6JbPOrI.mp4
  - boost type eraser, starts from 35mins, for common interface, used like detection or concept
[E] The lazy programmer's guide to writing thousands of tests - Scott Wlaschin-IYzDFHx6QPY.mp4
  - property testing with QuickCheck
      ```
      # commutativity
      let r1 = add(x, y)
      let r2 = add(y, x)
      assert(r1 == r2)

      # associativity
      let r1 = add(add(x, 1), 1)
      let r2 = add(x, 2)
      assert(r1 == r2)

      # identity
      let r1 = add(x, 0)
      assert(r1 == 0)
      ```
[E] Things I Learnt While Trying to Avoid Becoming a CMake Expert - CB Bailey - ACCU 2022 [852VSXFaDO0].mp4
  - basic stuff and best practices
[E] Things that Matter - Scott Meyers _ DConf2017-RT46MpK39rQ.mp4
[D] This Videogame Developer Used the STL and You'll Never Guess What Happened - Mathieu Ropert - ACCU21-xoEUO9DezV8.mp4
  - 1994, 486 starts not to execute instructions in sequentially
[T] Threads Considered Harmful - Lucian Radu Teodorescu [ ACCU 2021 ]-_T1XjxXNSCs.mp4
[D] Timur Doumler - How C++20 changes the way we write code - Meeting C++ 2020-VK-16tpFQVI.mp4
[E] Timur Doumler - Type punning in modern C++-Nn7zugKc32Q.mp4
    ```cpp
    // before c++ 20 std::bit_cast
    template <typename To, typename From,
              typename = std::enable_if_t<
                  (sizeof(To) == sizeof(From)) &&
                  std::is_trivially_copable_v<From> &&
                  std::is_trivially_copable_v<To>>>
    To bit_cast(const From& src) noexcept {
      To dst;
      std::memcpy(&dst, &src, sizeof(To));
      return dst;
    }
    ```
  1. aliasing rules
  2. object lifetime rules
    - an object is created by
      1. a definition
      2. a new-expression
      3. when implicitly changing the active member of a union
      4. or when a temporary object is created
  3. alignment rules
  4. rules for valid value representations
    - "If there is no value of type To corresponding to the value representation produced, the behavior is undefined"
  - c++20 malloc starts lifetime
  - c++23 std::start_lifetime_as replaces reinterpret_cast from char to object
  - Beware of reinterpret_cast<char*>(&obj), it is to one char, not a char array. may or may not be ok, not clear, Chandler said it is ok
  - two objects are _pointer-interconveritible_
      ```cpp
      struct Widget {
        int i = 42;
        float f = 0;
      };

      int main() {
        Widget w;
        int i = *reinterpret_cast<int*>(&w); // ok
        return i;
      }
      ```
[E] Tobias Hieta - Compiling C++ is slow - let's go faster-X4pyOtawqjg.mp4
  - 1h45m to 36m
  - ninja for incrementable build, marginly for full build
  - clang as compiler, 3x faster
  - lld as linker, especially for debug build, 1x% faster
  - PCH, `target_precompile_headers(Test PUBLIC StdAfx.h)`, 20% faster
  - `-DCMAKE_CXX_COMPILER_LAUNCHER=ccache` result is complicated
    - cold cache is slow
    - hot cache can be incredibly faster
    - to think about
      - cache sharing(sccache)
      - local builds vs CI
      - hard to debug
  - unity build, `-DCMAKE_UNITY_BUILD=ON`, 40% faster
  - PIMPL
  - build clang with LTO, `-DLLVM_ENABLE_LTO=Thin`, x% faster
  - build clang with PGO, 20% faster
    1. build clang with `-DLLVM_BUILD_INSTRUMENTED=IR`
    2. train clang with souce code with different settings
    3. merge all profraw files with llvm-prodata
    4. feed output to clang cmake with `-DLLVM_PROFDATA_FILE=<path>`
    5. combine with LTO for best results
  - post link optimization
    - LLVM-BOLT
    - LLVM-Propeller
  - grab bag
    - `-fvisibility=hidden` should be default, which shrinks the linking table
    - `-fexperimental-new-pass-manager`
    - distcc
    - `-ftime-trace`
[A] Tony van Eerd - C++ Memory Model & Lock-Free Programming-14ntPfyNaKE.mp4
[T] True parallelism, with no concept of threads - Alfred Bratterud - Meeting C++ 2017-9IXivbSA_5A.mp4
[D] Type safe C++ – LOL!  --) - Bjorn Fahller [ACCU 2018]-SWHvNvY-PHw.mp4
  - "Did you just slice an orange into an apple?" -- Peter Bindels
      ```cpp
      enum class Orange{};
      enum class Apple{};

      int main() {
        Orange o{4};
        Apple a{3};
        Apple x{o}; // Oops
      }
      ```
  - compare different strong type libs
[D] Undefined Behavior is Not an Error - Barbara Geller, Ansel Sermersheim - code - -dive 2019-x-ZDZ1CcP3k.mp4
[E] Understanding Compiler Optimization - Chandler Carruth - Opening Keynote Meeting C++ 2015-FnGCDLhaxKU.mp4
  - inlining is the single most important optimization in modern compilers
[D] Unicode in C++ - James McNellis - Meeting C++ 2016-tOHnXt3Ycfo.mp4
[E] Using Concepts - C++ Design in a Concept World (part 1 of 2) - Jeff Garland - [CppNow 2021]-Ffu9C1BZ4-c.mp4
[E] Using Concepts - C++ Design in a Concept World (part 2 of 2) - Jeff Garland - [CppNow 2021]-IXbf5lxGtr0.mp4
[E] Walter E. Brown - Correctly calculating min, max and more - Meeting C++ online-V1U6AXEgNbE.mp4
  - [alg.sorting.general]/5: A sequence is _sorted_ if, for every iterator i and non-negative integer n, *(i + n) < *i is false
  - given two values a and b, in that order:
    - min should prefer to return a, and
    - max should prefer to return b
  - never should max and min return the same item
    - when values a and b are in     order, min should return a / max should return b
    - when values a and b are out of order, min should return b / max should return a
  - we should always prefer algorithmic _stability_
      ```cpp
      auto min(auto a, auto b) { return out_of_order(a, b) ? b : a; }
      auto max(auto a, auto b) { return out_of_order(a, b) ? a : b; }
      bool out_of_order(auto a, auto b) { return b < a; }
      ```
  - floating points comparison
[D] Want fast C++ Know your hardware! - Timur Doumler - Meeting C++ 2016-a12jYibw0vs.mp4
  - cache associativity
    - 128KB L2 cache and 8 way associativity
    - 8 sets, 16KB per set
    - say have 20 ints but they are all 16KB apart
    - so each int only can go one slot of each set
    - that's 20 ints for 8 slots
  - align data for SSE vectorization
[E] What is an ABI, and Why is Breaking it Bad - Marshall Clow - CppCon 2020-7RoTDjLLXJQ.mp4
[D] When Should You Give Two Things the Same Name - Arthur O'Dwyer - [CppNow 2021] [OQgFEkgKx2s].mp4
[E] Why C++ Sails When the Vasa Sank [ltCgzYcpFUI].mp4
  - compatible with C
  - single most importand features: Destructors. Then templates and overloading. A language for library writers
  - "The reason that c++ is complicated is because you're all sick"
[T] Working with Asynchrony Generically - A Tour of C++ Executors (part 1_2) - Eric Niebler - CppCon 21-xLboNIf7BTg.mp4
[T] Working with Asynchrony Generically - A Tour of C++ Executors (part 2_2) - Eric Niebler - CppCon 21-6a0zzUBUNW4.mp4
[D] Writing better embedded Software - Dan Saks - Keynote Meeting Embedded 2018-3VtGCPIoBfs.mp4
[D] Writing cache friendly C++ - Jonathan Müller - Meeting C++ 2018-Nz9SiF0QVKY.mp4
  - sizeof(T) % alignof(T) == 0
  - https://github.com/foonathan/tiny
[E] [MUC++] Ben Deane - 'The Construction and Use of C++ Algorithms' (Virtual Meetup)-jCfbyjAyAKU.mp4
    ```cpp
    template <typename InputIt1, typename InputIt2, typename OutputIt>
    OutputIt zip(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first) {
      return std::transform(first1, last1, first2, d_first, [](const auto& a, const auto& b) { return std::pair(a, b); });
    }

    bool starts_with(const std::string& s, const std::string_view prefix) {
      return std::mismatch(std::cbegin(s), std::cend(s), std::cbegin(prefix), std::cend(prefix), std::equal_to{}).second == std::cend(prefix);
    }
    ```
  - find one of the missing values in an unsorted int64 array
      ```cpp
      template<std::forward_iterator I, typename T = std::iter_value_t<I>>
      constexpr T min_unused(I first, I last, T value) {
        using diff_t = decltype(value - value);
        while (first != last) {
          const auto half = (std::distance(first, last) + 1) / 2;
          const auto m = value + diff_t(half);
          const auto p = std::partition(first, last, [&](const auto x) { return x < m; });
          if (p == std::next(first, half)) {
            first = p;
            value = m;
          } else {
            last = p;
          }
        }
        return value;
      }
  - std::invoke can call member functions, so no f(args..), but std::invoke(f, args..)?
  - four algorithmic principles
    1. useful returns: a procedure should return all the potentially useful information it computed
    2. separating types: do not assume that two types are the same when they my be different
    3. completeness: when designing an interface, consider providing all the related procedures
    4. itnerface refinement: design interfaces, like designing programs, is a multi-pass activity
[D] [MUC++] Inbal Levi - 'Exceptions Under the Spotlight' (Virtual)-7mQBfl2K-5Y.mp4
[D] [MUC++] Jonathan Müller - 'The Static Initialization Order Fiasco' (Virtual Meetup)-dlTrziwQU-w.mp4
[D] [MUC++] Jonathan O'Connor - Template Shenanigans - Testing, Debugging and Benchmarking Template Code-TQQf4z-laBA.mp4
[E] [MUC++] Nicolai Josuttis - 'The Nightmare of Initialization in C++'-MTzUvmREiu0.mp4
[D] [MUC++] Phil Nash - 'Test Driven C++' (Part 1)-MqNqi_OvnXA.mp4
[D] [MUC++] Phil Nash - 'Test Driven C++' (Part 2)-OZFhRjzaC0o.mp4
[D] [MUC++] Sándor Dargó - Strongly typed containers-QXE43Zqr_WM.mp4
[D] [MUC++] Timur Doumler - Real-time Programming with the C++ Standard Library-G3qOKiPf1WQ.mp4
[E] [noise filtered] Optimizing Generic Algorithms - Denis Yaroshevskiy - Meeting C++ 2019-10MQW-aJU3g.mp4
  - same code, but 4.2x performance difference due to code alignment
[D] code - -dive 2016 conference – Chandler Carruth – Making C++ easier, faster and safer (part 1)-cX_GhJ6BuWI.mp4
  - clang-tidy and clang-format
[D] code - -dive 2016 conference – Chandler Carruth – Panel-style extended Q&A _ AmA-430o2HMODj4.mp4
[D] code - -dive 2016 conference – Chandler Carruth –Making C++ easier, faster, safer (part 2)-E36BUcTWo50.mp4
  - sanitiers, fuzzer
[D] code - -dive 2016 conference – Kevlin Henney – Clean Coders Hate (…) When You Use These (…) Tricks-brfqm9k6qzc.mp4
[D] code - -dive 2016 conference – Sean Parent – Better Code-cK_kftBNgBc.mp4
[E] code - -dive 2017 – Mateusz Pusz – Striving for ultimate low latency-vzDl0Q91MrM.mp4
  - sw vs hw: 1- 10us vs 100- 1000ns
  - low latency network, modern hardware, BIOS profiling, kernel profiling, OS profiling, then c++
  - SPIN
    - don't sleep
    - don't context switch
    - prefer single-threaded scheduling
    - disable locking and thread support
    - disable power management
    - disable C-states
    - disable interrupt coalescing
  - PIN
    - assign CPU affinity
    - assign interrupt affinity
    - assign memory to NUMA nodes
    - consider the physical location of NICs
    - isolate cores from general OS use
    - use a system with a single physical CPU
  - DROP-IN
    - choose NIC vendors based on performance and availability of drop-in kernel bypass libraries
    - use the kernel bypass library
  - fast path has to start and finish as soon as possible, has predicatable and reproducible performance (low jitter)
  - google code base is not thread safe
  - use CRTP to replace inheritance. Java perf cannot be as good as c++
  - no dynamic allocation
      ```cpp
      template<std::size_t MaxSize>
      class inplace_string {
        std::array<value_type, MaxSize + 1> chars_;
      public:
        // string-like interface
      };
      ```
  - compile-time branching
      ```cpp
      enum class side { BID, ASK };

      class order_book {
        template <side S> class book_side {
          using compare = std::conditional_t<S==side::BID, std::greater<>, std::less<>>;
          std::vector<price> levels_;
        public:
          void insert(order o) {
            const auto it = lower_bound(begin(levels_), end(levels_), o.price, compare());
            if (it != end(levels) && *it != o.price)
              levels_.insert(it, o.price);
          }
          bool match(price p) const {
            return compare()(levels_.back(), p);
          }
        };
      };

      book_side<side::BID> bids_;
      book_side<side::ASK> asks_;
      ```
  - divide the code to hot and cold paths, google vector example, split cold code to one separate function improves performance 1:10:20, 20% faster
  - consider using tsl::hopscotch_map
  - free list or plf::colony for preallocate storage
  - how to develop system with low-latency constraints
    - keep the _number of threads_ close(less or equal) to the number of available _physical CPU cores_
    - _Separate_ IO threads from business logic threads (unless business logic is extremely lightweight)
    - use fixed size _lock free queues_/_busy spins_ to pass the
    - use optimal _algorithms_ / _data structures and _data locality_ principle
    - _precompute_, use compile time instread of runtime whenever possible
    - _the simpiler the code, the faster it is likely to be_
    - Do not try to be smarter than the compiler
    - Know the _language_, _tools_ and _libraries_
    - Know your _hardware_
    - _Bypass the kernel_ (100% user space code)
    - **Measure** performance... ALWAYS
[E] code - -dive 2017 – Odin Holmes – The fastest template metaprogramming in the West-ZpVPexZHYrQ.mp4
  - some really advanced template programming tricks
[E] code - -dive conference 2014 - Scott Meyers - Cpu Caches and Why You Care-WDIkqP4JbkE.mp4
[D] itCppCon21 Welcome (Marco Arena) + KEYNOTE 'WARNING - std - -find is broken' (Sean Parent)-NO5wHzI_oug.mp4
  - Unary Predicate cannot be stateful
  - unsigned can be faster than signed integer
[T] std - -jthread - I Told You Concurrency Is Tricky - Nico Josuttis [ ACCU 2021 ]-ln5ERAVXEMY.mp4
[D] x86 Internals for Fun & Profit • Matt Godbolt • GOTO 2014 [hgcNM-6wr34].mp4
